<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>POINTS — Sequences Editor</title>

  <!-- Handsontable Community Edition -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@14.6.1/dist/handsontable.full.min.css">
  <script src="https://cdn.jsdelivr.net/npm/handsontable@14.6.1/dist/handsontable.full.min.js"></script>
  <!-- SheetJS — reads/writes xlsx, ods, csv and many other formats -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }
    body {
      display: flex;
      flex-direction: column;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 13px;
      background: #f8f9fa;
      color: #222;
    }

    /* ── App bar ──────────────────────────────────────────── */
    #app-bar {
      background: #6bc3c5;
      color: #fff;
      height: 46px;
      padding: 0 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,.18);
      z-index: 10;
    }
    #app-logo {
      width: 28px; height: 28px;
      background: #fff;
      border-radius: 4px;
      display: flex; align-items: center; justify-content: center;
      font-size: 17px;
      flex-shrink: 0;
    }
    #app-title { font-size: 17px; font-weight: 600; letter-spacing: .2px; }
    #app-subtitle { font-size: 12px; opacity: .75; margin-left: 2px; }

    /* ── Toolbar ──────────────────────────────────────────── */
    #toolbar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 4px 10px;
      display: flex;
      align-items: center;
      gap: 3px;
      flex-shrink: 0;
      flex-wrap: wrap;
      min-height: 38px;
    }

    .tb-btn {
      border: 1px solid transparent;
      background: transparent;
      border-radius: 3px;
      cursor: pointer;
      padding: 0 7px;
      height: 26px;
      min-width: 26px;
      font-size: 13px;
      color: #3c3c3c;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: background .1s, border-color .1s;
      user-select: none;
      white-space: nowrap;
    }
    .tb-btn:hover  { background: #f1f3f4; border-color: #dadce0; }
    .tb-btn.active { background: #e8f0fe; border-color: #4285f4; color: #1a73e8; }
    .tb-btn:focus  { outline: none; }

    .tb-sep { width: 1px; height: 20px; background: #e0e0e0; margin: 0 5px; flex-shrink: 0; }

    .tb-select {
      border: 1px solid #e0e0e0;
      border-radius: 3px;
      background: #fff;
      height: 26px;
      padding: 0 4px;
      font-size: 13px;
      color: #3c3c3c;
      cursor: pointer;
    }
    .tb-select:focus { outline: none; border-color: #4285f4; }

    .color-wrap {
      display: flex; flex-direction: column; align-items: center;
      gap: 1px; cursor: pointer;
    }
    .color-label { font-size: 10px; color: #888; line-height: 1; }
    .color-swatch {
      width: 26px; height: 20px;
      border: 1px solid #ccc; border-radius: 2px;
      cursor: pointer; padding: 1px;
    }

    /* SVG / PNG Download buttons */
    #btn-svg, #btn-png {
      background: #1a73e8;
      color: #fff;
      border: none;
      border-radius: 4px;
      height: 28px;
      padding: 0 14px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background .15s;
      flex-shrink: 0;
    }
    #btn-svg:hover, #btn-png:hover { background: #1558b0; }

    /* ── Formula bar ──────────────────────────────────────── */
    #formula-bar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 3px 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      height: 32px;
    }
    #cell-addr {
      width: 58px;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 2px;
      font-size: 12px;
      text-align: center;
      background: #fafafa;
    }
    #cell-addr:focus { outline: none; border-color: #4285f4; background: #fff; }
    #fx-label { color: #aaa; font-style: italic; font-size: 15px; flex-shrink: 0; }
    #formula-in {
      flex: 1;
      padding: 2px 6px;
      border: 1px solid transparent;
      border-radius: 2px;
      font-size: 13px;
      background: transparent;
    }
    #formula-in:focus { outline: none; border-color: #4285f4; background: #fff; }

    /* ── Spreadsheet area ──────────────────────────────────── */
    #main-area   { flex: 1; display: flex; overflow: hidden; }
    #sheet-wrap  { flex: 1; overflow: hidden; position: relative; }
    #sheet       { width: 100%; height: 100%; }

    /* ── File library panel ───────────────────────────────── */
    #file-panel {
      width: 210px;
      min-width: 210px;
      background: #fff;
      border-left: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width .2s ease, min-width .2s ease;
    }
    #file-panel.closed { width: 0; min-width: 0; }
    #file-panel-header {
      padding: 8px 10px 6px;
      font-size: 12px;
      font-weight: 600;
      color: #555;
      letter-spacing: .3px;
      border-bottom: 1px solid #e0e0e0;
      white-space: nowrap;
      flex-shrink: 0;
    }
    #file-list {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
    }
    .file-entry {
      padding: 7px 12px;
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #333;
      user-select: none;
    }
    .file-entry:hover    { background: #f1f3f4; }
    .file-entry.active   { background: #e8f0fe; color: #1a73e8; font-weight: 600; }

    /* Handsontable tweaks */
    .handsontable .htCore td {
      vertical-align: middle;
      font-size: 16px;        /* default size */
      text-align: center;     /* default alignment */
      white-space: nowrap;
      overflow: visible;
    }
    .handsontable .htCore th { background: #f1f3f4; color: #555; font-weight: 600; }

    /* ── Border-icon buttons ──────────────────────────────── */
    /* Small box with one thick side to show which border is set */
    .bord-ico {
      width: 13px; height: 13px;
      border: 1px solid #bbb;
      display: inline-block;
      flex-shrink: 0;
    }
    .bord-ico.t { border-top:    2.5px solid #333; }
    .bord-ico.r { border-right:  2.5px solid #333; }
    .bord-ico.b { border-bottom: 2.5px solid #333; }
    .bord-ico.l { border-left:   2.5px solid #333; }
    .bord-ico.a { border:        2.5px solid #333; }
    /* Active state: highlight the thick side in blue */
    .tb-btn.active .bord-ico.t { border-top-color:    #1a73e8; }
    .tb-btn.active .bord-ico.r { border-right-color:  #1a73e8; }
    .tb-btn.active .bord-ico.b { border-bottom-color: #1a73e8; }
    .tb-btn.active .bord-ico.l { border-left-color:   #1a73e8; }
    .tb-btn.active .bord-ico.a { border-color:        #1a73e8; }

    /* ── Grid hide ────────────────────────────────────────── */
    /* Grid visibility is handled in afterRenderer via inline styles
       so that custom borders stay visible even when the grid is hidden. */

    /* ── Status bar ───────────────────────────────────────── */
    #status-bar {
      background: #fff;
      border-top: 1px solid #e0e0e0;
      padding: 2px 14px;
      font-size: 11px;
      color: #777;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-shrink: 0;
      height: 24px;
    }
    #st-msg { margin-left: auto; color: #1a73e8; font-weight: 500; }

    /* ── Toast notification ───────────────────────────────── */
    #toast {
      position: fixed; bottom: 36px; left: 50%; transform: translateX(-50%);
      background: #323232; color: #fff;
      padding: 8px 18px; border-radius: 4px;
      font-size: 13px; pointer-events: none;
      opacity: 0; transition: opacity .25s;
      z-index: 9999;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>

<!-- ── App bar ──────────────────────────────────────────────────────────── -->
<div id="app-bar">
  <div id="app-logo">&#9783;</div>
  <span id="app-title">POINTS</span>
  <span id="app-subtitle">Sequences Editor</span>
</div>

<!-- ── Toolbar ──────────────────────────────────────────────────────────── -->
<div id="toolbar">

  <!-- Font family -->
  <select class="tb-select" id="sel-font" style="width:114px;" title="Font">
    <option value="Arial">Arial</option>
    <option value="Verdana">Verdana</option>
    <option value="Georgia">Georgia</option>
    <option value="Trebuchet MS">Trebuchet MS</option>
    <option value="Courier New">Courier New</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Impact">Impact</option>
  </select>

  <!-- Font size -->
  <select class="tb-select" id="sel-size" style="width:54px;" title="Dimensione">
    <option>8</option><option>9</option><option>10</option><option>11</option>
    <option>12</option><option>13</option><option>14</option>
    <option selected>16</option><option>18</option><option>20</option><option>22</option>
    <option>24</option><option>28</option><option>32</option><option>36</option>
    <option>48</option><option>72</option>
  </select>

  <div class="tb-sep"></div>

  <!-- Style buttons -->
  <button class="tb-btn" id="btn-bold"      title="Bold (Ctrl+B)"><b>B</b></button>
  <button class="tb-btn" id="btn-italic"    title="Italic (Ctrl+I)"><i>I</i></button>
  <button class="tb-btn" id="btn-underline" title="Underline (Ctrl+U)"><u>U</u></button>
  <button class="tb-btn" id="btn-strike"    title="Strikethrough"><s>S</s></button>

  <div class="tb-sep"></div>

  <!-- Color pickers -->
  <div class="color-wrap" title="Text color">
    <span class="color-label">A</span>
    <input type="color" class="color-swatch" id="inp-color" value="#000000">
  </div>
  <div class="color-wrap" title="Background color" style="margin-left:4px;">
    <span class="color-label" style="font-size:12px;">&#9608;</span>
    <input type="color" class="color-swatch" id="inp-bg" value="#ffffff">
  </div>

  <div class="tb-sep"></div>

  <!-- Clear format -->
  <button class="tb-btn" id="btn-clear-fmt" title="Clear formatting">&#10006; Fmt</button>

  <div class="tb-sep"></div>

  <!-- Cell borders -->
  <button class="tb-btn" id="btn-bord-t" title="Top border">   <span class="bord-ico t"></span></button>
  <button class="tb-btn" id="btn-bord-l" title="Left border">  <span class="bord-ico l"></span></button>
  <button class="tb-btn" id="btn-bord-b" title="Bottom border"><span class="bord-ico b"></span></button>
  <button class="tb-btn" id="btn-bord-r" title="Right border"> <span class="bord-ico r"></span></button>
  <button class="tb-btn" id="btn-bord-a" title="All borders">  <span class="bord-ico a"></span></button>

  <div class="tb-sep"></div>

  <!-- Grid visibility toggle -->
  <button class="tb-btn active" id="btn-grid" title="Show/hide grid">&#9783; Grid</button>
  <button class="tb-btn" id="btn-grid-minus" title="Decrease cell size" style="font-size:16px; padding:0 9px;">−</button>
  <button class="tb-btn" id="btn-grid-plus"  title="Increase cell size" style="font-size:16px; padding:0 9px;">+</button>

  <!-- Spacer -->
  <div style="flex:1; min-width:8px;"></div>

  <!-- Import / Export -->
  <input type="file" id="file-input"
    accept=".xlsx,.xls,.ods,.csv,.wsheet,.html,.htm"
    style="display:none">
  <button class="tb-btn" id="btn-library"
    title="Open/close file library">&#128218; Library</button>
  <button class="tb-btn" id="btn-open"
    title="Open file (xlsx, ods, csv, .wsheet, Google Sheets html)">&#128193; Open</button>
  <button class="tb-btn" id="btn-save-ws"
    title="Save full sheet with formatting and borders (.wsheet)">&#8659; Save</button>

  <div class="tb-sep"></div>

  <!-- SVG / PNG export -->
  <button id="btn-svg" title="Export selected cells as SVG">&#11015; SVG</button>
  <button id="btn-png" title="Export selected cells as PNG">&#11015; PNG</button>
</div>

<!-- ── Formula bar ──────────────────────────────────────────────────────── -->
<div id="formula-bar">
  <input type="text" id="cell-addr" value="A1" readonly>
  <span id="fx-label">ƒx</span>
  <input type="text" id="formula-in" placeholder="Value...">
</div>

<!-- ── Spreadsheet + File panel ─────────────────────────────────────────── -->
<div id="main-area">
  <div id="sheet-wrap">
    <div id="sheet"></div>
  </div>

  <div id="file-panel" class="closed">
    <div id="file-panel-header">&#128218; Library</div>
    <div id="file-list"></div>
  </div>
</div>

<!-- ── Status bar ───────────────────────────────────────────────────────── -->
<div id="status-bar">
  <span id="st-cells">Ready</span>
  <span id="st-avg"></span>
  <span id="st-sum"></span>
  <span id="st-msg"></span>
</div>

<!-- Toast -->
<div id="toast"></div>

<script>
'use strict';

/* ═══════════════════════════════════════════════════════════
   CELL FORMAT STORE
   cellFormats[row][col] = { bold, italic, underline, strike,
     color, bgColor, fontSize, fontFamily, align }
═══════════════════════════════════════════════════════════ */
const cellFormats = {};

function getFmt(row, col) {
  if (!cellFormats[row]) cellFormats[row] = {};
  if (!cellFormats[row][col]) cellFormats[row][col] = {};
  return cellFormats[row][col];
}

function applyFmt(props) {
  const sel = hot.getSelected();
  if (!sel) return;
  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++)
        Object.assign(getFmt(r, c), props);
  }
  hot.render();
  const s = hot.getSelected();
  if (s && s.length) syncToolbar(s[0][0], s[0][1]);
}

function toggleFmt(key) {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  const [r, c] = sel[0];
  applyFmt({ [key]: !getFmt(r, c)[key] });
}

/* ═══════════════════════════════════════════════════════════
   UTILITIES
═══════════════════════════════════════════════════════════ */
function colLetter(col) {
  let s = ''; col++;
  while (col > 0) {
    s = String.fromCharCode(65 + (col - 1) % 26) + s;
    col = Math.floor((col - 1) / 26);
  }
  return s;
}
function cellAddr(r, c) { return colLetter(c) + (r + 1); }

function escapeXml(s) {
  return String(s)
    .replace(/&/g,  '&amp;')
    .replace(/</g,  '&lt;')
    .replace(/>/g,  '&gt;')
    .replace(/"/g,  '&quot;')
    .replace(/'/g, '&apos;');
}

function showToast(msg, ms = 2800) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), ms);
}

/* ═══════════════════════════════════════════════════════════
   CELL BORDERS STORE  (declared here so afterRenderer can access it)
   cellBorders[row][col] = { top, right, bottom, left }
═══════════════════════════════════════════════════════════ */
const cellBorders = {};

/* Declared here so afterRenderer can access it during initial render */
let gridVisible = true;

/* ═══════════════════════════════════════════════════════════
   HANDSONTABLE
═══════════════════════════════════════════════════════════ */
const hot = new Handsontable(document.getElementById('sheet'), {
  data: Handsontable.helper.createEmptySpreadsheetData(400, 50),
  rowHeaders: true,
  colHeaders: true,
  contextMenu: {
    items: {
      copy: {
        name: 'Copy',
        callback: () => copyToClipboard(),
      },
      cut: {
        name: 'Cut',
        callback: () => {
          copyToClipboard(); /* sets internalClipboard synchronously */
          const s = hot.getSelected();
          if (!s) return;
          const changes = [];
          for (const [r1, c1, r2, c2] of s) {
            for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++)
              for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++)
                changes.push([r, c, null]);
          }
          hot.setDataAtCell(changes);
        },
      },
      paste: {
        name: 'Paste',
        callback: () => pasteFromClipboard(),
      },
      row_above:  {},
      row_below:  {},
      col_left:   {},
      col_right:  {},
      remove_row: {},
      remove_col: {},
      add_50_rows: {
        name: 'Add 50 rows',
        callback() {
          const sel = hot.getSelected();
          const afterRow = sel ? Math.max(...sel.map(([r1,,r2]) => Math.max(r1, r2))) : hot.countRows() - 1;
          hot.alter('insert_row_below', afterRow, 50);
        },
      },
      add_50_cols: {
        name: 'Add 50 columns',
        callback() {
          const sel = hot.getSelected();
          const afterCol = sel ? Math.max(...sel.map(([,c1,,c2]) => Math.max(c1, c2))) : hot.countCols() - 1;
          hot.alter('insert_col_end', afterCol, 50);
        },
      },
    },
  },
  manualColumnResize: false,
  manualRowResize: false,
  selectionMode: 'multiple',
  outsideClickDeselects: false,
  width:  '100%',
  height: '100%',
  licenseKey: 'non-commercial-and-evaluation',
  colWidths: 36,
  rowHeights: 36,
  customBorders: false,
  wordWrap: false,

  afterRenderer(TD, row, col) {
    const fmt = cellFormats[row]?.[col];
    if (fmt) {
      TD.style.fontWeight = fmt.bold   ? 'bold'   : '';
      TD.style.fontStyle  = fmt.italic ? 'italic' : '';
      const dec = [];
      if (fmt.underline) dec.push('underline');
      if (fmt.strike)    dec.push('line-through');
      TD.style.textDecoration  = dec.join(' ') || '';
      TD.style.color           = fmt.color      || '';
      TD.style.backgroundColor = (fmt.bgColor && fmt.bgColor !== '#ffffff') ? fmt.bgColor : '';
      TD.style.fontSize        = fmt.fontSize   ? fmt.fontSize + 'px' : '';
      TD.style.fontFamily      = fmt.fontFamily || '';
      TD.style.textAlign       = fmt.align      || '';
    }

    /* ── Borders (virtual rendering — only visible cells) ──────────────────
       We must set style+width+color together: color/width alone won't draw
       a border if borderStyle is still 'none' (HoT only sets right/bottom
       as default grid lines; top/left have no CSS border at all).       */
    const b      = cellBorders[row]?.[col] || {};
    const hidden = !gridVisible;
    const bSides = ['Top', 'Right', 'Bottom', 'Left'];
    const bKeys  = ['top', 'right', 'bottom', 'left'];
    for (let _i = 0; _i < 4; _i++) {
      const S  = bSides[_i];
      const on = b[bKeys[_i]];
      if (on) {
        TD.style['border' + S + 'Style'] = 'solid';
        TD.style['border' + S + 'Width'] = '1.5px';
        TD.style['border' + S + 'Color'] = '#000000';
      } else if (hidden) {
        TD.style['border' + S + 'Style'] = 'solid';
        TD.style['border' + S + 'Width'] = '1px';
        TD.style['border' + S + 'Color'] = 'transparent';
      } else {
        TD.style['border' + S + 'Style'] = '';
        TD.style['border' + S + 'Width'] = '';
        TD.style['border' + S + 'Color'] = '';
      }
    }
  },

  afterSelection(r, c) {
    updateFormulaBar(r, c);
    syncToolbar(r, c);
    updateStatus();
  },

  afterChange(changes) {
    if (!changes) return;
    const s = hot.getSelected();
    if (s && s.length) updateFormulaBar(s[0][0], s[0][1]);
    updateStatus();
  },
});

/* ═══════════════════════════════════════════════════════════
   FORMULA BAR
═══════════════════════════════════════════════════════════ */
const addrEl = document.getElementById('cell-addr');
const fxEl   = document.getElementById('formula-in');

function updateFormulaBar(row, col) {
  addrEl.value = cellAddr(row, col);
  const v = hot.getDataAtCell(row, col);
  fxEl.value = (v == null) ? '' : String(v);
}

fxEl.addEventListener('keydown', (e) => {
  if (e.key !== 'Enter' && e.key !== 'Tab') return;
  e.preventDefault();
  const s = hot.getSelected();
  if (!s || !s.length) return;
  const [r, c] = s[0];
  hot.setDataAtCell(r, c, fxEl.value);
  hot.selectCell(r, c);
});
fxEl.addEventListener('blur', () => {
  const s = hot.getSelected();
  if (!s || !s.length) return;
  hot.setDataAtCell(s[0][0], s[0][1], fxEl.value);
});

/* ═══════════════════════════════════════════════════════════
   TOOLBAR STATE SYNC
═══════════════════════════════════════════════════════════ */
function syncToolbar(row, col) {
  const fmt = cellFormats[row]?.[col] || {};

  document.getElementById('btn-bold').classList.toggle('active',      !!fmt.bold);
  document.getElementById('btn-italic').classList.toggle('active',    !!fmt.italic);
  document.getElementById('btn-underline').classList.toggle('active', !!fmt.underline);
  document.getElementById('btn-strike').classList.toggle('active',    !!fmt.strike);

  document.getElementById('inp-color').value = fmt.color      || '#000000';
  document.getElementById('inp-bg').value    = fmt.bgColor    || '#ffffff';
  document.getElementById('sel-size').value  = fmt.fontSize   || 16; /* CSS default is 16 */
  document.getElementById('sel-font').value  = fmt.fontFamily || 'Arial';

  /* Border buttons reflect anchor cell's current state */
  const bfmt = cellBorders[row]?.[col] || {};
  document.getElementById('btn-bord-t').classList.toggle('active', !!bfmt.top);
  document.getElementById('btn-bord-r').classList.toggle('active', !!bfmt.right);
  document.getElementById('btn-bord-b').classList.toggle('active', !!bfmt.bottom);
  document.getElementById('btn-bord-l').classList.toggle('active', !!bfmt.left);
}

/* ═══════════════════════════════════════════════════════════
   STATUS BAR
═══════════════════════════════════════════════════════════ */
function updateStatus() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  let count = 0, sum = 0, nums = 0;
  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    count += (rMax - rMin + 1) * (cMax - cMin + 1);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++) {
        const v = parseFloat(hot.getDataAtCell(r, c));
        if (!isNaN(v)) { sum += v; nums++; }
      }
  }
  document.getElementById('st-cells').textContent = `Cells: ${count}`;
  document.getElementById('st-sum').textContent   = nums ? `Sum: ${sum}` : '';
  document.getElementById('st-avg').textContent   = nums ? `Avg: ${(sum / nums).toFixed(2)}` : '';
}

/* ═══════════════════════════════════════════════════════════
   TOOLBAR WIRING
═══════════════════════════════════════════════════════════ */
document.getElementById('btn-bold').onclick      = () => toggleFmt('bold');
document.getElementById('btn-italic').onclick    = () => toggleFmt('italic');
document.getElementById('btn-underline').onclick = () => toggleFmt('underline');
document.getElementById('btn-strike').onclick    = () => toggleFmt('strike');

document.getElementById('sel-font').onchange = (e) => applyFmt({ fontFamily: e.target.value });
document.getElementById('sel-size').onchange = (e) => applyFmt({ fontSize: parseInt(e.target.value) });
document.getElementById('inp-color').oninput  = (e) => applyFmt({ color: e.target.value });
document.getElementById('inp-bg').oninput     = (e) => applyFmt({ bgColor: e.target.value });

document.getElementById('btn-clear-fmt').onclick = () => {
  const sel = hot.getSelected();
  if (!sel) return;
  for (const [r1, c1, r2, c2] of sel) {
    for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++) {
      for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++) {
        if (cellFormats[r]) delete cellFormats[r][c];
        if (cellBorders[r]) delete cellBorders[r][c];
      }
    }
  }
  hot.render();
  const s = hot.getSelected();
  if (s && s.length) syncToolbar(s[0][0], s[0][1]);
  showToast('Formatting cleared.');
};

/* ═══════════════════════════════════════════════════════════
   CLIPBOARD
   internalClipboard stores the full cell state (values, formatting,
   borders) so that a same-session paste restores everything.
   A plain TSV is also written to the system clipboard for
   interoperability with external apps (Excel, Sheets, etc.).
   External pastes (Ctrl+V when the system clipboard differs
   from our last copy) are treated as TSV-only: only values are
   pasted and existing destination formatting/borders are kept.
═══════════════════════════════════════════════════════════ */
let internalClipboard = null; /* { tsv, grid:[[{v, fmt, bfmt}]] } */

async function copyToClipboard() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }

  const tsvRows = [];
  const grid    = [];
  for (let r = rMin; r <= rMax; r++) {
    const rowTsv  = [];
    const rowData = [];
    for (let c = cMin; c <= cMax; c++) {
      const v    = hot.getDataAtCell(r, c);
      const vStr = (v == null) ? '' : String(v);
      rowTsv.push(vStr);
      rowData.push({
        v,
        fmt:  cellFormats[r]?.[c]  ? { ...cellFormats[r][c] }  : null,
        bfmt: cellBorders[r]?.[c]  ? { ...cellBorders[r][c] }  : null,
      });
    }
    tsvRows.push(rowTsv.join('\t'));
    grid.push(rowData);
  }

  const tsv = tsvRows.join('\n');
  internalClipboard = { tsv, grid }; /* set synchronously — used by paste immediately */
  try { await navigator.clipboard.writeText(tsv); }
  catch { /* clipboard API unavailable — internal clipboard still works */ }
}

async function pasteFromClipboard() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  const r0 = Math.min(sel[0][0], sel[0][2]);
  const c0 = Math.min(sel[0][1], sel[0][3]);

  /* Check if system clipboard matches our last internal copy */
  let systemText = null;
  try { systemText = await navigator.clipboard.readText(); } catch { /* ignore */ }

  const useInternal = internalClipboard &&
    (!systemText || systemText === internalClipboard.tsv);

  if (useInternal) {
    /* ── Full paste: values + formatting + borders ── */
    const changes = [];
    internalClipboard.grid.forEach((row, ri) => {
      row.forEach((cell, ci) => {
        const r = r0 + ri, c = c0 + ci;
        changes.push([r, c, cell.v]);

        /* Restore formatting */
        if (!cellFormats[r]) cellFormats[r] = {};
        if (cell.fmt) cellFormats[r][c] = { ...cell.fmt };
        else          delete cellFormats[r][c];

        /* Restore borders */
        if (!cellBorders[r]) cellBorders[r] = {};
        if (cell.bfmt) cellBorders[r][c] = { ...cell.bfmt };
        else           delete cellBorders[r][c];
        applyBorderToCell(r, c);
      });
    });
    hot.setDataAtCell(changes);
    hot.render();
  } else if (systemText) {
    /* ── External paste: TSV only — formatting/borders untouched ── */
    const parsed = systemText.replace(/\r\n?/g, '\n').trimEnd()
      .split('\n').map(row => row.split('\t'));
    hot.setDataAtCell(
      parsed.flatMap((row, ri) => row.map((v, ci) => [r0 + ri, c0 + ci, v]))
    );
  } else {
    showToast("Concedi l'accesso agli appunti al browser");
  }
}

/* ── Keyboard shortcuts ─────────────────────────────────────── */
document.addEventListener('keydown', async (e) => {
  if (!(e.ctrlKey || e.metaKey) || e.shiftKey || e.altKey) return;

  if (e.key === 'b') { e.preventDefault(); toggleFmt('bold');           return; }
  if (e.key === 'i') { e.preventDefault(); toggleFmt('italic');         return; }
  if (e.key === 'u') { e.preventDefault(); toggleFmt('underline');      return; }
  if (e.key === 'c') { e.preventDefault(); await copyToClipboard();     return; }
  if (e.key === 'v') { e.preventDefault(); await pasteFromClipboard();  return; }
  if (e.key === 'x') {
    e.preventDefault();
    await copyToClipboard();
    const s = hot.getSelected();
    if (!s) return;
    const changes = [];
    for (const [r1, c1, r2, c2] of s)
      for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++)
        for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++)
          changes.push([r, c, null]);
    hot.setDataAtCell(changes);
    return;
  }
});

/* ═══════════════════════════════════════════════════════════
   SVG / PNG EXPORT
═══════════════════════════════════════════════════════════ */

/* Get actual rendered column width */
function getColW(col) {
  try { const w = hot.getColWidth(col); return (w > 0) ? w : 50; }
  catch { return 50; }
}

/* Get actual rendered row height (from DOM if available, else fallback) */
function getRowH(row) {
  const td = hot.getCell(row, 0);
  if (td?.parentElement) return td.parentElement.offsetHeight || 50;
  return 50;
}

/* Build SVG markup for the given cell range. Returns { svg, totalW, totalH }. */
function buildSvg(rMin, rMax, cMin, cMax) {
  const PAD     = 5;
  const CBORD_W = 1.5;
  const CBORD_C = '#000000';

  const colWidths  = Array.from({ length: cMax - cMin + 1 }, (_, i) => getColW(cMin + i));
  const rowHeights = Array.from({ length: rMax - rMin + 1 }, (_, i) => getRowH(rMin + i));
  const totalW = colWidths.reduce((a, b) => a + b, 0);
  const totalH = rowHeights.reduce((a, b) => a + b, 0);

  let defs = '<defs>';
  let body = '';
  let yOff = 0;

  for (let r = rMin; r <= rMax; r++) {
    const rh = rowHeights[r - rMin];
    let xOff = 0;

    for (let c = cMin; c <= cMax; c++) {
      const cw  = colWidths[c - cMin];
      const uid = `cp_${r}_${c}`;

      defs +=
        `<clipPath id="${uid}">` +
        `<rect x="${xOff + PAD}" y="${yOff + 1}" ` +
        `width="${Math.max(0, cw - PAD * 2)}" height="${rh - 2}"/>` +
        `</clipPath>`;

      const fmt = cellFormats[r]?.[c] || {};
      const fg  = fmt.color      || '#222222';
      const fs  = fmt.fontSize   || 16;
      const ff  = fmt.fontFamily || 'Arial';
      const fw  = fmt.bold       ? 'bold'   : 'normal';
      const fi  = fmt.italic     ? 'italic' : 'normal';
      const decParts = [];
      if (fmt.underline) decParts.push('underline');
      if (fmt.strike)    decParts.push('line-through');
      const deco = decParts.join(' ') || 'none';

      if (fmt.bgColor && fmt.bgColor !== '#ffffff') {
        body +=
          `<rect x="${xOff}" y="${yOff}" width="${cw}" height="${rh}" ` +
          `fill="${fmt.bgColor}"/>`;
      }

      const val = hot.getDataAtCell(r, c);
      if (val !== null && val !== undefined && val !== '') {
        body +=
          `<text x="${xOff + cw / 2}" y="${yOff + rh / 2}" ` +
          `font-family="${escapeXml(ff)}, sans-serif" ` +
          `font-size="${fs}" font-weight="${fw}" font-style="${fi}" ` +
          `text-decoration="${deco}" fill="${fg}" ` +
          `text-anchor="middle" dominant-baseline="middle" ` +
          `clip-path="url(#${uid})">${escapeXml(String(val))}</text>`;
      }

      const b  = cellBorders[r]?.[c] || {};
      const bl = `stroke="${CBORD_C}" stroke-width="${CBORD_W}" stroke-linecap="square"`;
      if (b.top)    body += `<line x1="${xOff}"    y1="${yOff}"    x2="${xOff+cw}" y2="${yOff}"    ${bl}/>`;
      if (b.bottom) body += `<line x1="${xOff}"    y1="${yOff+rh}" x2="${xOff+cw}" y2="${yOff+rh}" ${bl}/>`;
      if (b.left)   body += `<line x1="${xOff}"    y1="${yOff}"    x2="${xOff}"    y2="${yOff+rh}" ${bl}/>`;
      if (b.right)  body += `<line x1="${xOff+cw}" y1="${yOff}"    x2="${xOff+cw}" y2="${yOff+rh}" ${bl}/>`;

      xOff += cw;
    }
    yOff += rh;
  }

  defs += '</defs>';
  const svg =
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<svg xmlns="http://www.w3.org/2000/svg" ` +
    `width="${totalW}" height="${totalH}" ` +
    `viewBox="0 0 ${totalW} ${totalH}">\n` +
    `  ${defs}\n  ${body}\n</svg>`;

  return { svg, totalW, totalH };
}

/* ── Selection bounding box helper ── */
function selectionBounds() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return null;
  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }
  return { rMin, rMax, cMin, cMax };
}

document.getElementById('btn-svg').onclick = () => {
  const bounds = selectionBounds();
  if (!bounds) { showToast('Select cells first!'); return; }
  const { rMin, rMax, cMin, cMax } = bounds;
  const { svg, totalW, totalH } = buildSvg(rMin, rMax, cMin, cMax);
  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = Object.assign(document.createElement('a'), { href: url, download: `sheet-${Date.now()}.svg` });
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  showToast(`SVG exported — ${totalW}×${totalH}px`);
};

document.getElementById('btn-png').onclick = () => {
  const bounds = selectionBounds();
  if (!bounds) { showToast('Select cells first!'); return; }
  const { rMin, rMax, cMin, cMax } = bounds;
  const { svg, totalW, totalH } = buildSvg(rMin, rMax, cMin, cMax);

  const scale  = 2; /* 2× for crisp retina output */
  const canvas = Object.assign(document.createElement('canvas'), {
    width:  totalW * scale,
    height: totalH * scale,
  });
  const ctx = canvas.getContext('2d');
  ctx.scale(scale, scale);

  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const img  = new Image();
  img.onload = () => {
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);
    const pngUrl = canvas.toDataURL('image/png');
    const a = Object.assign(document.createElement('a'), { href: pngUrl, download: `sheet-${Date.now()}.png` });
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    showToast(`PNG exported — ${totalW}×${totalH}px (${scale}×)`);
  };
  img.onerror = () => { URL.revokeObjectURL(url); showToast('PNG export failed.'); };
  img.src = url;
};

/* ═══════════════════════════════════════════════════════════
   CUSTOM BORDERS
   State is tracked in cellBorders[row][col] = { top, right, bottom, left }
   (cellBorders is declared above, before Handsontable initialization)
═══════════════════════════════════════════════════════════ */

function getBordFmt(row, col) {
  if (!cellBorders[row]) cellBorders[row] = {};
  if (!cellBorders[row][col]) cellBorders[row][col] = {};
  return cellBorders[row][col];
}

/* applyBorderToCell: kept for paste compatibility — borders live in
   cellBorders store and are rendered by afterRenderer (virtual). */
function applyBorderToCell(/* row, col — no-op, hot.render() called by caller */) {}

function toggleBorder(side) {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  const enable = !getBordFmt(sel[0][0], sel[0][1])[side];

  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++)
        getBordFmt(r, c)[side] = enable;
  }
  hot.render();
  syncToolbar(sel[0][0], sel[0][1]);
}

document.getElementById('btn-bord-t').onclick = () => toggleBorder('top');
document.getElementById('btn-bord-l').onclick = () => toggleBorder('left');
document.getElementById('btn-bord-b').onclick = () => toggleBorder('bottom');
document.getElementById('btn-bord-r').onclick = () => toggleBorder('right');

/* Outer border: draws a border only on the perimeter of the selection box,
   leaving inner cells untouched. */
document.getElementById('btn-bord-a').onclick = () => {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  /* Compute the overall bounding box across all selection areas */
  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }

  for (let r = rMin; r <= rMax; r++) {
    for (let c = cMin; c <= cMax; c++) {
      const onEdge = r === rMin || r === rMax || c === cMin || c === cMax;
      if (!onEdge) continue;
      const b = getBordFmt(r, c);
      if (r === rMin) b.top    = true;
      if (r === rMax) b.bottom = true;
      if (c === cMin) b.left   = true;
      if (c === cMax) b.right  = true;
    }
  }
  hot.render();
  syncToolbar(sel[0][0], sel[0][1]);
};

/* ═══════════════════════════════════════════════════════════
   GRID TOGGLE + SIZE
   (gridVisible is declared above, before Handsontable initialization)
═══════════════════════════════════════════════════════════ */
document.getElementById('btn-grid').onclick = () => {
  gridVisible = !gridVisible;
  document.getElementById('btn-grid').classList.toggle('active', gridVisible);
  hot.render();
};

let cellSize = 36;
document.getElementById('btn-grid-minus').onclick = () => {
  cellSize = Math.max(16, cellSize - 6);
  hot.updateSettings({ colWidths: cellSize, rowHeights: cellSize });
};
document.getElementById('btn-grid-plus').onclick = () => {
  cellSize = Math.min(150, cellSize + 6);
  hot.updateSettings({ colWidths: cellSize, rowHeights: cellSize });
};

/* Resize */
window.addEventListener('resize', () => hot.refreshDimensions());

/* ═══════════════════════════════════════════════════════════
   IMPORT / EXPORT
   • xlsx/ods/csv — via SheetJS (data only)
   • .wsheet      — JSON snapshot with data + formatting + borders
═══════════════════════════════════════════════════════════ */

/* ── Export: .wsheet (full state — data + formatting + borders) ── */
function exportWSheet() {
  /* Trim trailing empty rows from data */
  const raw = hot.getData();
  let lastRow = raw.length - 1;
  while (lastRow >= 0 && raw[lastRow].every(v => v === null || v === '')) lastRow--;

  const state = {
    version: 1,
    data:    raw.slice(0, lastRow + 1),
    formats: cellFormats,
    borders: cellBorders,
  };
  const json = JSON.stringify(state);
  const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = Object.assign(document.createElement('a'), {
    href: url, download: `websheet-${Date.now()}.wsheet`,
  });
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  showToast('Saved: websheet.wsheet');
}

/* ── .wsheet loader (shared by file import and auto-load) ── */
async function loadWSheetText(text, name) {
  const state = JSON.parse(text);
  if (!state || state.version !== 1) throw new Error('Invalid format');

  document.getElementById('st-msg').textContent = 'Loading…';
  await new Promise(r => requestAnimationFrame(r)); /* yield — browser paints "Loading…" */

  /* Clear current state */
  Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
  Object.keys(cellBorders).forEach(k => delete cellBorders[k]);

  /* Load data */
  hot.loadData(state.data || []);

  /* Restore formatting */
  if (state.formats) {
    for (const [r, cols] of Object.entries(state.formats))
      for (const [c, fmt] of Object.entries(cols)) {
        if (!cellFormats[r]) cellFormats[r] = {};
        cellFormats[r][c] = fmt;
      }
  }

  /* Restore borders into store — afterRenderer applies them (virtual, no plugin) */
  if (state.borders) {
    for (const [r, cols] of Object.entries(state.borders))
      for (const [c, bfmt] of Object.entries(cols)) {
        if (!cellBorders[r]) cellBorders[r] = {};
        cellBorders[r][c] = bfmt;
      }
  }

  hot.render(); /* single render — afterRenderer applies formats + borders for visible cells */
  document.getElementById('st-msg').textContent = '';
  if (name) showToast(`Opened: ${name}`);
}

/* ═══════════════════════════════════════════════════════════
   GOOGLE SHEETS HTML IMPORT
   Parses the CSS classes from the <style> block, then reads
   the .waffle table cells applying borders + formatting.
═══════════════════════════════════════════════════════════ */
function parsePtPx(val) {
  const pt = val.match(/^([\d.]+)pt$/i);
  if (pt) return Math.round(parseFloat(pt[1]) * 1.333);
  const px = val.match(/^([\d.]+)px$/i);
  if (px) return Math.round(parseFloat(px[1]));
  return null;
}

function normColor(val) {
  val = val.trim();
  if (val.startsWith('#')) return val.toLowerCase();
  const m = val.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
  if (m) return '#' + [m[1], m[2], m[3]].map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
  return null;
}

function parseCssClass(decls) {
  const result = {};
  for (const raw of decls.split(';')) {
    const colon = raw.indexOf(':');
    if (colon === -1) continue;
    const key = raw.slice(0, colon).trim().toLowerCase();
    const val = raw.slice(colon + 1).trim();
    const vl  = val.toLowerCase();

    if (key === 'font-weight' && vl === 'bold')   { result.bold = true; continue; }
    if (key === 'font-style'  && vl === 'italic')  { result.italic = true; continue; }
    if (key === 'color')       { const c = normColor(val); if (c) result.color = c; continue; }
    if (key === 'background-color') { const c = normColor(val); if (c) result.bgColor = c; continue; }
    if (key === 'text-align')  { if (['left','center','right'].includes(vl)) result.align = vl; continue; }
    if (key === 'font-size')   { const s = parsePtPx(val); if (s) result.fontSize = s; continue; }
    if (key === 'font-family') {
      const families = val.split(',').map(f => f.replace(/["']/g, '').trim());
      result.fontFamily = families.find(f => !f.toLowerCase().startsWith('docs-')) || families[0];
      continue;
    }
    /* Borders: value like "1px SOLID #000000" means on; "none" means off */
    if (key === 'border-top')    { result.borderTop    = !vl.includes('none'); continue; }
    if (key === 'border-bottom') { result.borderBottom = !vl.includes('none'); continue; }
    if (key === 'border-left')   { result.borderLeft   = !vl.includes('none'); continue; }
    if (key === 'border-right')  { result.borderRight  = !vl.includes('none'); continue; }
  }
  return result;
}

function handleGoogleSheetsHtml(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const doc = new DOMParser().parseFromString(e.target.result, 'text/html');

      /* 1 ── Parse CSS class map */
      const styleMap = {};
      for (const styleEl of doc.querySelectorAll('style')) {
        const re = /\.waffle\s+\.(\w+)\s*\{([^}]*)\}/g;
        let m;
        while ((m = re.exec(styleEl.textContent)) !== null) {
          styleMap[m[1]] = parseCssClass(m[2]);
        }
      }

      /* 2 ── Read waffle table */
      const table = doc.querySelector('table.waffle');
      if (!table) throw new Error('No Google Sheets table found (table.waffle missing)');

      const aoa        = [];
      const newFormats = {};
      const newBorders = {};

      for (const tr of table.querySelectorAll('tbody tr')) {
        const cells   = tr.querySelectorAll('td');
        const rowIdx  = aoa.length;
        const rowData = [];

        cells.forEach((td, colIdx) => {
          rowData.push(td.textContent.trim());

          const cls = (td.className || '').trim();
          const s   = styleMap[cls];
          if (!s) return;

          /* Formatting */
          const fmt = {};
          if (s.bold)       fmt.bold       = true;
          if (s.italic)     fmt.italic     = true;
          if (s.color     && s.color     !== '#000000') fmt.color     = s.color;
          if (s.bgColor   && s.bgColor   !== '#ffffff') fmt.bgColor   = s.bgColor;
          if (s.fontSize)   fmt.fontSize   = s.fontSize;
          if (s.fontFamily) fmt.fontFamily = s.fontFamily;
          if (s.align)      fmt.align      = s.align;
          if (Object.keys(fmt).length) {
            if (!newFormats[rowIdx]) newFormats[rowIdx] = {};
            newFormats[rowIdx][colIdx] = fmt;
          }

          /* Borders */
          if (s.borderTop || s.borderBottom || s.borderLeft || s.borderRight) {
            if (!newBorders[rowIdx]) newBorders[rowIdx] = {};
            newBorders[rowIdx][colIdx] = {
              top:    !!s.borderTop,
              bottom: !!s.borderBottom,
              left:   !!s.borderLeft,
              right:  !!s.borderRight,
            };
          }
        });

        aoa.push(rowData);
      }

      /* 3 ── Load into Handsontable */
      Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
      Object.keys(cellBorders).forEach(k => delete cellBorders[k]);
      hot.loadData(aoa);

      for (const [r, cols] of Object.entries(newFormats)) {
        if (!cellFormats[r]) cellFormats[r] = {};
        Object.assign(cellFormats[r], cols);
      }
      for (const [r, cols] of Object.entries(newBorders)) {
        if (!cellBorders[r]) cellBorders[r] = {};
        for (const [c, bfmt] of Object.entries(cols)) cellBorders[r][c] = bfmt;
      }

      hot.render(); /* single render */
      const borderTotal = Object.values(newBorders).reduce((n, cols) => n + Object.keys(cols).length, 0);
      showToast(`Opened: ${file.name} (${aoa.length} rows, ${borderTotal} bordered cells)`);
    } catch (err) {
      showToast(`Error: ${err.message}`);
    }
  };
  reader.readAsText(file, 'utf-8');
}

/* ── Import: detect format and load ── */
function handleFileImport(file) {
  if (!file) return;
  const name = file.name.toLowerCase();

  if (name.endsWith('.html') || name.endsWith('.htm')) {
    handleGoogleSheetsHtml(file);
    return;
  }

  if (name.endsWith('.wsheet')) {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try { await loadWSheetText(e.target.result, file.name); }
      catch (err) { showToast(`Error: ${err.message}`); }
    };
    reader.readAsText(file);

  } else {
    /* ── xlsx / ods / csv / xls: SheetJS ── */
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb   = XLSX.read(data, { type: 'array', cellStyles: true });
        const ws   = wb.Sheets[wb.SheetNames[0]];
        const aoa  = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });

        /* Clear formatting and borders */
        Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
        Object.keys(cellBorders).forEach(k => delete cellBorders[k]);

        hot.loadData(aoa);

        /* Extract borders from xlsx cell styles into store */
        const ref = ws['!ref'];
        if (ref) {
          const range = XLSX.utils.decode_range(ref);
          for (let r = range.s.r; r <= range.e.r; r++) {
            for (let c = range.s.c; c <= range.e.c; c++) {
              const cell = ws[XLSX.utils.encode_cell({ r, c })];
              if (!cell?.s?.border) continue;
              const b = cell.s.border;
              if (!b.top?.style && !b.bottom?.style && !b.left?.style && !b.right?.style) continue;
              if (!cellBorders[r]) cellBorders[r] = {};
              cellBorders[r][c] = {
                top:    !!b.top?.style,
                bottom: !!b.bottom?.style,
                left:   !!b.left?.style,
                right:  !!b.right?.style,
              };
            }
          }
        }

        hot.render(); /* single render */
        showToast(`Opened: ${file.name} (${wb.SheetNames[0]})`);
      } catch (err) {
        showToast(`Error reading file: ${err.message}`);
      }
    };
    reader.readAsArrayBuffer(file);
  }
}

/* ── Wire buttons ── */
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', (e) => {
  handleFileImport(e.target.files[0]);
  e.target.value = ''; /* reset so the same file can be opened again */
});

document.getElementById('btn-open').onclick    = () => fileInput.click();
document.getElementById('btn-save-ws').onclick = exportWSheet;

/* ═══════════════════════════════════════════════════════════
   FILE LIBRARY PANEL
═══════════════════════════════════════════════════════════ */
let libraryOpen   = false;
let activeEntry   = null;

const filePanel   = document.getElementById('file-panel');
const fileListEl  = document.getElementById('file-list');
const btnLibrary  = document.getElementById('btn-library');

function toggleLibrary() {
  libraryOpen = !libraryOpen;
  filePanel.classList.toggle('closed', !libraryOpen);
  btnLibrary.classList.toggle('active', libraryOpen);
  if (libraryOpen) hot.refreshDimensions();
}

function loadLibraryFile(filename, entryEl) {
  fetch(`./data/${encodeURIComponent(filename)}`)
    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.text(); })
    .then(async text => {
      await loadWSheetText(text, filename);
      if (activeEntry) activeEntry.classList.remove('active');
      activeEntry = entryEl;
      entryEl.classList.add('active');
    })
    .catch(err => showToast(`Error loading ${filename}: ${err.message}`));
}

fetch('./data/index.json')
  .then(r => r.json())
  .then(files => {
    fileListEl.innerHTML = '';
    for (const f of files) {
      const el = document.createElement('div');
      el.className = 'file-entry';
      el.title = f;
      el.textContent = f.replace(/\.wsheet$/i, '');
      el.onclick = () => loadLibraryFile(f, el);
      fileListEl.appendChild(el);
    }
  })
  .catch(() => {
    fileListEl.innerHTML = '<div style="padding:10px;color:#aaa;font-size:11px;">No files found</div>';
  });

btnLibrary.onclick = toggleLibrary;

/* ── Auto-load template on startup ── */
fetch('./data/template.wsheet')
  .then(r => { if (!r.ok) throw new Error(); return r.text(); })
  .then(text => loadWSheetText(text, null).catch(() => {}))
  .catch(() => {}); /* silently skip if file is missing */
</script>
</body>
</html>
