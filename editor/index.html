<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>POINTS — Sequences Editor</title>

  <!-- Handsontable Community Edition -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@14.6.1/dist/handsontable.full.min.css">
  <script src="https://cdn.jsdelivr.net/npm/handsontable@14.6.1/dist/handsontable.full.min.js"></script>
  <!-- SheetJS — reads/writes xlsx, ods, csv and many other formats -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Firebase SDK (compat v10) -->
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.0.0/firebase-database-compat.js"></script>
  <!-- Firebase config — file locale (gitignored), generato da GitHub Actions in produzione -->
  <script src="firebase-config.js"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }
    body {
      display: flex;
      flex-direction: column;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 13px;
      background: #f8f9fa;
      color: #222;
    }

    /* ── App bar ──────────────────────────────────────────── */
    #app-bar {
      background: #6bc3c5;
      color: #fff;
      height: 46px;
      padding: 0 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,.18);
      z-index: 10;
    }
    #app-logo {
      width: 28px; height: 28px;
      background: #fff;
      border-radius: 4px;
      display: flex; align-items: center; justify-content: center;
      font-size: 17px;
      flex-shrink: 0;
    }
    #app-title { font-size: 17px; font-weight: 600; letter-spacing: .2px; }
    #app-subtitle { font-size: 12px; opacity: .75; margin-left: 2px; }

    /* ── Toolbar ──────────────────────────────────────────── */
    #toolbar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 4px 10px;
      display: flex;
      align-items: center;
      gap: 3px;
      flex-shrink: 0;
      flex-wrap: wrap;
      min-height: 38px;
    }

    .tb-btn {
      border: 1px solid transparent;
      background: transparent;
      border-radius: 3px;
      cursor: pointer;
      padding: 0 7px;
      height: 26px;
      min-width: 26px;
      font-size: 13px;
      color: #3c3c3c;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: background .1s, border-color .1s;
      user-select: none;
      white-space: nowrap;
    }
    .tb-btn:hover  { background: #f1f3f4; border-color: #dadce0; }
    .tb-btn.active { background: #e8f0fe; border-color: #4285f4; color: #1a73e8; }
    .tb-btn:focus  { outline: none; }

    .tb-sep { width: 1px; height: 20px; background: #e0e0e0; margin: 0 5px; flex-shrink: 0; }

    .tb-select {
      border: 1px solid #e0e0e0;
      border-radius: 3px;
      background: #fff;
      height: 26px;
      padding: 0 4px;
      font-size: 13px;
      color: #3c3c3c;
      cursor: pointer;
    }
    .tb-select:focus { outline: none; border-color: #4285f4; }

    .color-wrap {
      display: flex; flex-direction: column; align-items: center;
      gap: 1px; cursor: pointer;
    }
    .color-label { font-size: 10px; color: #888; line-height: 1; }
    .color-swatch {
      width: 26px; height: 20px;
      border: 1px solid #ccc; border-radius: 2px;
      cursor: pointer; padding: 1px;
    }

    /* SVG / PNG Download buttons */
    #btn-svg, #btn-png {
      background: #1a73e8;
      color: #fff;
      border: none;
      border-radius: 4px;
      height: 28px;
      padding: 0 14px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background .15s;
      flex-shrink: 0;
    }
    #btn-svg:hover, #btn-png:hover { background: #1558b0; }

    /* ── Formula bar ──────────────────────────────────────── */
    /* ── Spreadsheet area ──────────────────────────────────── */
    #main-area   { flex: 1; display: flex; overflow: hidden; }
    #sheet-wrap  { flex: 1; overflow: hidden; position: relative; }
    #sheet       { width: 100%; height: 100%; }

    /* ── File library panel ───────────────────────────────── */
    #file-panel {
      width: 210px;
      min-width: 210px;
      background: #fff;
      border-left: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width .2s ease, min-width .2s ease;
    }
    #file-panel.closed { width: 0; min-width: 0; }
    #file-panel-header {
      padding: 8px 10px 6px;
      font-size: 12px;
      font-weight: 600;
      color: #555;
      letter-spacing: .3px;
      border-bottom: 1px solid #e0e0e0;
      white-space: nowrap;
      flex-shrink: 0;
    }
    #file-list {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
    }
    .file-entry {
      padding: 5px 6px 5px 12px;
      font-size: 12px;
      cursor: pointer;
      color: #333;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 2px;
    }
    .file-entry:hover  { background: #f1f3f4; }
    .file-entry.active { background: #e8f0fe; color: #1a73e8; font-weight: 600; }
    .file-entry-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      line-height: 1.4;
    }
    .file-entry-actions {
      display: flex; gap: 1px; flex-shrink: 0;
      opacity: 0; transition: opacity .12s;
    }
    .file-entry:hover .file-entry-actions,
    .file-entry.active .file-entry-actions { opacity: 1; }
    .fe-btn {
      width: 22px; height: 22px;
      border: none; background: transparent;
      border-radius: 3px; cursor: pointer;
      font-size: 12px; padding: 0;
      display: flex; align-items: center; justify-content: center;
      color: #888; flex-shrink: 0; line-height: 1;
    }
    .fe-btn:hover { background: rgba(0,0,0,.08); color: #333; }
    .fe-btn.del:hover { color: #c62828; background: rgba(198,40,40,.1); }

    /* ── File panel footer ─────────────────────────────── */
    #file-panel-footer { border-top: 1px solid #e0e0e0; padding: 7px 8px; flex-shrink: 0; }
    #btn-new-file {
      width: 100%; height: 28px;
      border: 1px dashed #ccc; background: transparent;
      border-radius: 4px; cursor: pointer;
      font-size: 12px; color: #888;
      transition: background .15s, border-color .15s, color .15s;
      display: none; /* shown only when logged in */
    }
    #btn-new-file:hover { background: #f1f3f4; border-color: #999; color: #333; }

    /* ── Library modals (name input + confirm delete) ─── */
    #libname-overlay, #libdel-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,.5);
      display: flex; align-items: center; justify-content: center;
      z-index: 10000;
      opacity: 0; pointer-events: none;
      transition: opacity .2s;
    }
    #libname-overlay.show, #libdel-overlay.show { opacity: 1; pointer-events: auto; }
    #libname-box, #libdel-box {
      background: #fff; border-radius: 8px;
      padding: 24px 28px; width: 300px;
      box-shadow: 0 8px 32px rgba(0,0,0,.25);
    }
    #libname-box h2, #libdel-box p {
      font-size: 14px; color: #222; margin-bottom: 16px;
    }
    #libdel-box p { font-weight: 400; line-height: 1.5; margin-bottom: 0; }
    #libname-error { color: #d32f2f; font-size: 12px; min-height: 16px; margin-bottom: 8px; }
    #btn-libdel-ok { background: #c62828 !important; }
    #btn-libdel-ok:hover { background: #b71c1c !important; }

    /* Handsontable tweaks */
    /* Remove HOT's default grey right/bottom cell borders — box-shadow in
       afterRenderer handles all visual grid lines and custom borders.
       border-collapse:collapse is left intact so HOT's hit-testing is correct. */
    .handsontable .htCore td {
      border-right:  none !important;
      border-bottom: none !important;
      padding: 0 !important;
      vertical-align: middle;
      text-align: center;
      white-space: nowrap;
      overflow: visible;
    }
    .handsontable .htCore th { background: #f1f3f4; color: #555; font-weight: 600; }

    /* ── Border popup (Ctrl/Cmd hover) ───────────────────── */
    #border-popup {
      position: fixed;
      display: none;
      flex-direction: row;
      gap: 2px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
      box-shadow: 0 3px 10px rgba(0,0,0,.18);
      padding: 4px;
      z-index: 9999;
    }
    #border-popup button {
      width: 30px; height: 30px;
      border: none; border-radius: 3px;
      background: transparent;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    #border-popup button:hover { background: #f1f3f4; }
    #border-popup button.active .bord-ico { outline: 2px solid #1a73e8; outline-offset: 1px; }

    /* ── Border-icon buttons ──────────────────────────────── */
    /* Small box with one thick side to show which border is set */
    .bord-ico {
      width: 13px; height: 13px;
      border: 1px solid #bbb;
      display: inline-block;
      flex-shrink: 0;
    }
    .bord-ico.t { border-top:    2.5px solid #333; }
    .bord-ico.r { border-right:  2.5px solid #333; }
    .bord-ico.b { border-bottom: 2.5px solid #333; }
    .bord-ico.l { border-left:   2.5px solid #333; }
    .bord-ico.a { border:        2.5px solid #333; }
    /* Active state: highlight the thick side in blue */
    .tb-btn.active .bord-ico.t { border-top-color:    #1a73e8; }
    .tb-btn.active .bord-ico.r { border-right-color:  #1a73e8; }
    .tb-btn.active .bord-ico.b { border-bottom-color: #1a73e8; }
    .tb-btn.active .bord-ico.l { border-left-color:   #1a73e8; }
    .tb-btn.active .bord-ico.a { border-color:        #1a73e8; }

    /* ── Grid hide ────────────────────────────────────────── */
    /* Grid visibility is handled in afterRenderer via inline styles
       so that custom borders stay visible even when the grid is hidden. */

    /* ── Status bar ───────────────────────────────────────── */
    #status-bar {
      background: #fff;
      border-top: 1px solid #e0e0e0;
      padding: 2px 14px;
      font-size: 11px;
      color: #777;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-shrink: 0;
      height: 24px;
    }
    #st-msg { margin-left: auto; color: #1a73e8; font-weight: 500; }
    #editing-warning { color: #e65100; font-weight: 500; display: none; }

    /* ── Toast notification ───────────────────────────────── */
    #toast {
      position: fixed; bottom: 36px; left: 50%; transform: translateX(-50%);
      background: #323232; color: #fff;
      padding: 8px 18px; border-radius: 4px;
      font-size: 13px; pointer-events: none;
      opacity: 0; transition: opacity .25s;
      z-index: 9999;
    }
    #toast.show { opacity: 1; }

    /* ── Auth area (app-bar right side) ──────────────────── */
    #auth-area { margin-left: auto; display: flex; align-items: center; gap: 8px; }
    #btn-login {
      background: rgba(255,255,255,.2);
      color: #fff;
      border: 1px solid rgba(255,255,255,.5);
      border-radius: 4px;
      height: 28px; padding: 0 12px;
      font-size: 12px; font-weight: 600; cursor: pointer;
      transition: background .15s;
    }
    #btn-login:hover { background: rgba(255,255,255,.35); }
    #user-info { display: none; align-items: center; gap: 8px; color: #fff; }
    #user-email { font-size: 12px; opacity: .85; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #btn-logout {
      background: rgba(255,255,255,.15);
      color: #fff; border: 1px solid rgba(255,255,255,.4);
      border-radius: 4px; height: 24px; padding: 0 8px;
      font-size: 11px; cursor: pointer; transition: background .15s;
    }
    #btn-logout:hover { background: rgba(255,255,255,.3); }

    /* ── Login modal ────────────────────────────────────── */
    #login-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,.5);
      display: flex; align-items: center; justify-content: center;
      z-index: 10000;
      opacity: 0; pointer-events: none;
      transition: opacity .2s;
    }
    #login-overlay.show { opacity: 1; pointer-events: auto; }
    #login-box {
      background: #fff; border-radius: 8px;
      padding: 28px 32px; width: 320px;
      box-shadow: 0 8px 32px rgba(0,0,0,.25);
    }
    #login-box h2 { font-size: 17px; font-weight: 700; color: #222; margin-bottom: 20px; }
    .login-field { margin-bottom: 14px; }
    .login-field label { display: block; font-size: 12px; color: #555; margin-bottom: 4px; font-weight: 500; }
    .login-field input {
      width: 100%; height: 34px;
      border: 1px solid #ccc; border-radius: 4px;
      padding: 0 10px; font-size: 13px;
      transition: border-color .15s;
    }
    .login-field input:focus { outline: none; border-color: #4285f4; }
    #login-error { color: #d32f2f; font-size: 12px; margin-bottom: 10px; min-height: 16px; }
    .login-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 4px; }
    .login-actions button {
      height: 32px; border-radius: 4px;
      font-size: 13px; font-weight: 600;
      cursor: pointer; padding: 0 18px;
      border: none; transition: background .15s;
    }
    #btn-login-cancel { background: #f1f3f4; color: #444; }
    #btn-login-cancel:hover { background: #e2e5e9; }
    #btn-login-submit { background: #1a73e8; color: #fff; }
    #btn-login-submit:hover { background: #1558b0; }
    #btn-login-submit:disabled { background: #aaa; cursor: default; }

    /* ── Save in Cloud button ────────────────────────────── */
    #btn-save-cloud {
      background: #34a853; color: #fff;
      border: none; border-radius: 4px;
      height: 28px; padding: 0 14px;
      font-size: 13px; font-weight: 600;
      cursor: pointer;
      display: none; /* shown only when logged in */
      align-items: center; gap: 6px;
      transition: background .15s;
      flex-shrink: 0;
    }
    #btn-save-cloud:hover { background: #2d9144; }
    #btn-save-cloud:disabled { background: #aaa; cursor: default; }
  </style>
</head>
<body>

<!-- ── App bar ──────────────────────────────────────────────────────────── -->
<div id="app-bar">
  <div id="app-logo">&#9783;</div>
  <span id="app-title">POINTS</span>
  <span id="app-subtitle">Sequences Editor</span>

  <!-- Auth area -->
  <div id="auth-area">
    <button id="btn-login" onclick="showLoginModal()">&#128274; Login</button>
    <div id="user-info">
      <span id="user-email"></span>
      <button id="btn-logout" onclick="logoutUser()">Logout</button>
    </div>
  </div>
</div>

<!-- ── Toolbar ──────────────────────────────────────────────────────────── -->
<div id="toolbar">

  <!-- Font size -->
  <select class="tb-select" id="sel-size" style="width:54px;" title="Dimensione">
    <option>8</option><option>9</option><option>10</option><option>11</option>
    <option>12</option><option>13</option><option>14</option>
    <option selected>16</option><option>18</option><option>20</option><option>22</option>
    <option>24</option><option>28</option><option>32</option><option>36</option>
    <option>48</option><option>72</option>
  </select>

  <!-- Color pickers -->
  <div class="color-wrap" title="Text color">
    <span class="color-label">A</span>
    <input type="color" class="color-swatch" id="inp-color" value="#000000">
  </div>
  <div class="color-wrap" title="Background color" style="margin-left:4px;">
    <span class="color-label" style="font-size:12px;">&#9608;</span>
    <input type="color" class="color-swatch" id="inp-bg" value="#ffffff">
  </div>

  <div class="tb-sep"></div>

  <!-- Cell borders + clear borders -->
  <button class="tb-btn" id="btn-bord-l" title="Left border">       <span class="bord-ico l"></span></button>
  <button class="tb-btn" id="btn-bord-r" title="Right border">      <span class="bord-ico r"></span></button>
  <button class="tb-btn" id="btn-bord-t" title="Top border">        <span class="bord-ico t"></span></button>
  <button class="tb-btn" id="btn-bord-b" title="Bottom border">     <span class="bord-ico b"></span></button>
  <button class="tb-btn" id="btn-bord-a" title="All borders">       <span class="bord-ico a"></span></button>
  <button class="tb-btn" id="btn-clear-fmt" title="Clear formatting"><span class="bord-ico"></span></button>

  <div class="tb-sep"></div>

  <!-- Grid visibility toggle -->
  <button class="tb-btn active" id="btn-grid" title="Show/hide grid">&#9783; Grid</button>
  <button class="tb-btn" id="btn-grid-minus" title="Decrease cell size" style="font-size:16px; padding:0 9px;">−</button>
  <button class="tb-btn" id="btn-grid-plus"  title="Increase cell size" style="font-size:16px; padding:0 9px;">+</button>

  <!-- Spacer -->
  <div style="flex:1; min-width:8px;"></div>

  <!-- Import / Export -->
  <input type="file" id="file-input"
    accept=".xlsx,.xls,.ods,.csv,.wsheet,.html,.htm"
    style="display:none">
  <button class="tb-btn" id="btn-library"
    title="Open/close file library">&#128218; Library</button>
  <button class="tb-btn" id="btn-open"
    title="Open file (xlsx, ods, csv, .wsheet, Google Sheets html)">&#128193; Open</button>
  <button class="tb-btn" id="btn-save-ws"
    title="Save full sheet with formatting and borders (.wsheet)">&#8659; Save</button>
  <button id="btn-save-cloud" onclick="saveToCloud()"
    title="Overwrite file on Firebase Cloud Storage">&#9729; Save in cloud</button>

  <div class="tb-sep"></div>

  <!-- SVG / PNG export -->
  <button id="btn-svg" title="Export selected cells as SVG">&#11015; SVG</button>
  <button id="btn-png" title="Export selected cells as PNG">&#11015; PNG</button>
</div>

<!-- ── Formula bar ──────────────────────────────────────────────────────── -->
<!-- ── Spreadsheet + File panel ─────────────────────────────────────────── -->
<div id="main-area">
  <div id="sheet-wrap">
    <div id="sheet"></div>
  </div>

  <div id="file-panel" class="closed">
    <div id="file-panel-header">&#128218; Library</div>
    <div id="file-list"></div>
    <div id="file-panel-footer">
      <button id="btn-new-file" onclick="showNewFileModal()" title="Create new file">+ New file</button>
    </div>
  </div>
</div>

<!-- ── Status bar ───────────────────────────────────────────────────────── -->
<div id="status-bar">
  <span id="st-cells">Ready</span>
  <span id="st-avg"></span>
  <span id="st-sum"></span>
  <span id="editing-warning"></span>
  <span id="st-msg"></span>
</div>

<!-- Toast -->
<div id="toast"></div>

<!-- ── Login modal ──────────────────────────────────────────────────────── -->
<div id="login-overlay">
  <div id="login-box">
    <h2>&#128274; Sign in</h2>
    <div class="login-field">
      <label for="login-email">Email</label>
      <input type="email" id="login-email" placeholder="your@email.com" autocomplete="email">
    </div>
    <div class="login-field">
      <label for="login-password">Password</label>
      <input type="password" id="login-password" placeholder="Password" autocomplete="current-password">
    </div>
    <div id="login-error"></div>
    <div class="login-actions">
      <button id="btn-login-cancel" onclick="hideLoginModal()">Cancel</button>
      <button id="btn-login-submit" onclick="submitLogin()">Sign in</button>
    </div>
  </div>
</div>

<!-- ── File name input modal (new file / rename) ────────────────────────── -->
<div id="libname-overlay">
  <div id="libname-box">
    <h2 id="libname-title">New file</h2>
    <div class="login-field">
      <label for="libname-input">File name</label>
      <input type="text" id="libname-input" placeholder="e.g. My Table">
    </div>
    <div id="libname-error"></div>
    <div class="login-actions">
      <button class="login-actions" id="btn-libname-cancel" onclick="hideLibNameModal()" style="background:#f1f3f4;color:#444;height:32px;border-radius:4px;font-size:13px;font-weight:600;cursor:pointer;padding:0 18px;border:none;">Cancel</button>
      <button id="btn-libname-ok" onclick="submitLibName()" style="background:#1a73e8;color:#fff;height:32px;border-radius:4px;font-size:13px;font-weight:600;cursor:pointer;padding:0 18px;border:none;">OK</button>
    </div>
  </div>
</div>

<!-- ── Delete confirm modal ──────────────────────────────────────────────── -->
<div id="libdel-overlay">
  <div id="libdel-box">
    <p id="libdel-msg"></p>
    <div class="login-actions" style="margin-top:16px;">
      <button onclick="hideLibDelModal()" style="background:#f1f3f4;color:#444;height:32px;border-radius:4px;font-size:13px;font-weight:600;cursor:pointer;padding:0 18px;border:none;">Cancel</button>
      <button id="btn-libdel-ok" onclick="submitLibDel()" style="color:#fff;height:32px;border-radius:4px;font-size:13px;font-weight:600;cursor:pointer;padding:0 18px;border:none;">Delete</button>
    </div>
  </div>
</div>

<!-- ── Border popup (Ctrl/Cmd + click on cell) ──────────────────────────── -->
<div id="border-popup">
  <button data-side="left"   title="Left border"   onclick="toggleBorder('left')">  <span class="bord-ico l"></span></button>
  <button data-side="right"  title="Right border"  onclick="toggleBorder('right')"> <span class="bord-ico r"></span></button>
  <button data-side="top"    title="Top border"    onclick="toggleBorder('top')">   <span class="bord-ico t"></span></button>
  <button data-side="bottom" title="Bottom border" onclick="toggleBorder('bottom')"><span class="bord-ico b"></span></button>
  <button id="bp-outer"      title="All borders"   onclick="document.getElementById('btn-bord-a').click()"><span class="bord-ico a"></span></button>
  <button id="bp-clear-fmt"  title="Clear formatting" onclick="document.getElementById('btn-clear-fmt').click()"><span class="bord-ico"></span></button>
</div>

<script>
'use strict';

/* ═══════════════════════════════════════════════════════════
   CELL FORMAT STORE
   cellFormats[row][col] = { bold, italic, underline, strike,
     color, bgColor, fontSize, fontFamily, align }
═══════════════════════════════════════════════════════════ */
const cellFormats = {};

function getFmt(row, col) {
  if (!cellFormats[row]) cellFormats[row] = {};
  if (!cellFormats[row][col]) cellFormats[row][col] = {};
  return cellFormats[row][col];
}

function applyFmt(props) {
  const sel = hot.getSelected();
  if (!sel) return;
  pushUndo(_snapshotCells(_selCells(sel)));
  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++)
        Object.assign(getFmt(r, c), props);
  }
  _isDirty = true;
  hot.render();
  const s = hot.getSelected();
  if (s && s.length) syncToolbar(s[0][0], s[0][1]);
}

function toggleFmt(key) {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  const [r, c] = sel[0];
  applyFmt({ [key]: !getFmt(r, c)[key] });
}

/* ═══════════════════════════════════════════════════════════
   UTILITIES
═══════════════════════════════════════════════════════════ */
function colLetter(col) {
  let s = ''; col++;
  while (col > 0) {
    s = String.fromCharCode(65 + (col - 1) % 26) + s;
    col = Math.floor((col - 1) / 26);
  }
  return s;
}
function cellAddr(r, c) { return colLetter(c) + (r + 1); }

function escapeXml(s) {
  return String(s)
    .replace(/&/g,  '&amp;')
    .replace(/</g,  '&lt;')
    .replace(/>/g,  '&gt;')
    .replace(/"/g,  '&quot;')
    .replace(/'/g, '&apos;');
}

function showToast(msg, ms = 2800) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), ms);
}

/* ═══════════════════════════════════════════════════════════
   CELL BORDERS STORE  (declared here so afterRenderer can access it)
   cellBorders[row][col] = { top, right, bottom, left }
═══════════════════════════════════════════════════════════ */
const cellBorders = {};

/* Declared here so afterRenderer can access them during initial render */
let gridVisible  = true;
let cellSize     = 36;
let baseFontSize = 16; /* scales with cellSize */

/* ═══════════════════════════════════════════════════════════
   UNDO STACK
   Each entry: array of { r, c, value, fmt, border }
   capturing the "before" state of affected cells.
═══════════════════════════════════════════════════════════ */
const undoStack = [];
const UNDO_LIMIT = 100;
let _undoing = false;

function _snapshotCells(cells) {
  return cells.map(([r, c]) => ({
    r, c,
    value:  hot.getDataAtCell(r, c),
    fmt:    cellFormats[r]?.[c] ? { ...cellFormats[r][c] } : null,
    border: cellBorders[r]?.[c] ? { ...cellBorders[r][c] } : null,
  }));
}

function _selCells(sel) {
  const out = [];
  for (const [r1, c1, r2, c2] of sel)
    for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++)
      for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++)
        out.push([r, c]);
  return out;
}

function pushUndo(snapshot) {
  if (_undoing) return;
  undoStack.push(snapshot);
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();
}

function performUndo() {
  if (!undoStack.length) return;
  _undoing = true;
  const snapshot = undoStack.pop();
  const changes = snapshot.map(({ r, c, value }) => [r, c, value ?? null]);
  for (const { r, c, fmt, border } of snapshot) {
    if (fmt)    { if (!cellFormats[r]) cellFormats[r] = {}; cellFormats[r][c] = { ...fmt }; }
    else        { if (cellFormats[r]) delete cellFormats[r][c]; }
    if (border) { if (!cellBorders[r]) cellBorders[r] = {}; cellBorders[r][c] = { ...border }; }
    else        { if (cellBorders[r]) delete cellBorders[r][c]; }
  }
  hot.setDataAtCell(changes);
  hot.render();
  _undoing = false;
  const s = hot.getSelected();
  if (s && s.length) syncToolbar(s[0][0], s[0][1]);
}

/* ═══════════════════════════════════════════════════════════
   HANDSONTABLE
═══════════════════════════════════════════════════════════ */
const hot = new Handsontable(document.getElementById('sheet'), {
  data: Handsontable.helper.createEmptySpreadsheetData(400, 50),
  rowHeaders: true,
  colHeaders: true,
  contextMenu: {
    items: {
      copy: {
        name: 'Copy',
        callback: () => copyToClipboard(),
      },
      cut: {
        name: 'Cut',
        callback: () => {
          copyToClipboard(); /* sets internalClipboard synchronously */
          const s = hot.getSelected();
          if (!s) return;
          const cells = _selCells(s);
          pushUndo(_snapshotCells(cells));
          const changes = cells.map(([r, c]) => {
            if (cellFormats[r]) delete cellFormats[r][c];
            if (cellBorders[r]) delete cellBorders[r][c];
            return [r, c, null];
          });
          hot.setDataAtCell(changes);
          hot.render();
        },
      },
      paste: {
        name: 'Paste',
        callback: () => pasteFromClipboard(),
      },
      row_above:  {},
      row_below:  {},
      col_left:   {},
      col_right:  {},
      remove_row: {},
      remove_col: {},
      add_50_rows: {
        name: 'Add 50 rows',
        callback() {
          const sel = hot.getSelected();
          const afterRow = sel ? Math.max(...sel.map(([r1,,r2]) => Math.max(r1, r2))) : hot.countRows() - 1;
          hot.alter('insert_row_below', afterRow, 50);
        },
      },
      add_50_cols: {
        name: 'Add 50 columns',
        callback() {
          const sel = hot.getSelected();
          const afterCol = sel ? Math.max(...sel.map(([,c1,,c2]) => Math.max(c1, c2))) : hot.countCols() - 1;
          hot.alter('insert_col_end', afterCol, 50);
        },
      },
    },
  },
  manualColumnResize: false,
  manualRowResize: false,
  selectionMode: 'multiple',
  outsideClickDeselects: false,
  width:  '100%',
  height: '100%',
  licenseKey: 'non-commercial-and-evaluation',
  colWidths: 36,
  rowHeights: 36,
  customBorders: false,
  wordWrap: false,

  afterRenderer(TD, row, col) {
    /* Always reset all inline styles so stale styles from DOM recycling don't persist */
    const fmt = cellFormats[row]?.[col];
    TD.style.fontSize        = fmt?.fontSize ? fmt.fontSize + 'px' : baseFontSize + 'px';
    TD.style.fontWeight      = fmt?.bold      ? 'bold'   : '';
    TD.style.fontStyle       = fmt?.italic    ? 'italic' : '';
    const dec = [];
    if (fmt?.underline) dec.push('underline');
    if (fmt?.strike)    dec.push('line-through');
    TD.style.textDecoration  = dec.join(' ') || '';
    TD.style.color           = fmt?.color     || '';
    TD.style.backgroundColor = (fmt?.bgColor && fmt.bgColor !== '#ffffff') ? fmt.bgColor : '';
    TD.style.fontFamily      = fmt?.fontFamily || '';
    TD.style.textAlign       = 'center';

    /* ── Borders via box-shadow (inset) ────────────────────────────────────
       HOT's default border-right/bottom are removed via CSS (border-collapse
       collapse is preserved for correct hit-testing).  With 0-width CSS
       borders, cells are effectively pixel-adjacent, so inset box-shadows
       drawn at each cell's edge produce a gap-free continuous line.         */
    const b  = cellBorders[row]?.[col] || {};
    const sh = [];
    if (b.top)    sh.push('inset 0 1px 0 0 #000');
    if (b.right)  sh.push('inset -1px 0 0 0 #000');
    if (b.bottom) sh.push('inset 0 -1px 0 0 #000');
    if (b.left)   sh.push('inset 1px 0 0 0 #000');
    if (gridVisible) {
      if (!b.right)  sh.push('inset -1px 0 0 0 #e0e0e0');
      if (!b.bottom) sh.push('inset 0 -1px 0 0 #e0e0e0');
    }
    TD.style.boxShadow = sh.join(', ') || '';
  },

  afterSelection(r, c) {
    syncToolbar(r, c);
    updateStatus();
  },

  beforeChange(changes, source) {
    if (_undoing || source !== 'edit') return;
    pushUndo(_snapshotCells(changes.map(([r, c]) => [r, c])));
  },

  afterChange(changes) {
    if (!changes) return;
    _isDirty = true;
    updateStatus();
  },
});

/* ═══════════════════════════════════════════════════════════
   FORMULA BAR
═══════════════════════════════════════════════════════════ */
/* ═══════════════════════════════════════════════════════════
   TOOLBAR STATE SYNC
═══════════════════════════════════════════════════════════ */
function syncToolbar(row, col) {
  const fmt = cellFormats[row]?.[col] || {};

  document.getElementById('sel-size').value  = fmt.fontSize   || baseFontSize;
  document.getElementById('inp-color').value = fmt.color      || '#000000';
  document.getElementById('inp-bg').value    = fmt.bgColor    || '#ffffff';

  /* Border buttons reflect anchor cell's current state */
  const bfmt = cellBorders[row]?.[col] || {};
  document.getElementById('btn-bord-t').classList.toggle('active', !!bfmt.top);
  document.getElementById('btn-bord-r').classList.toggle('active', !!bfmt.right);
  document.getElementById('btn-bord-b').classList.toggle('active', !!bfmt.bottom);
  document.getElementById('btn-bord-l').classList.toggle('active', !!bfmt.left);
  /* Keep border popup in sync when visible */
  const _bp = document.getElementById('border-popup');
  if (_bp && _bp.style.display === 'flex') {
    _bp.querySelectorAll('[data-side]').forEach(btn => {
      btn.classList.toggle('active', !!bfmt[btn.dataset.side]);
    });
  }
}

/* ═══════════════════════════════════════════════════════════
   STATUS BAR
═══════════════════════════════════════════════════════════ */
function updateStatus() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  let count = 0, sum = 0, nums = 0;
  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    count += (rMax - rMin + 1) * (cMax - cMin + 1);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++) {
        const v = parseFloat(hot.getDataAtCell(r, c));
        if (!isNaN(v)) { sum += v; nums++; }
      }
  }
  document.getElementById('st-cells').textContent = `Cells: ${count}`;
  document.getElementById('st-sum').textContent   = nums ? `Sum: ${sum}` : '';
  document.getElementById('st-avg').textContent   = nums ? `Avg: ${(sum / nums).toFixed(2)}` : '';
}

/* ═══════════════════════════════════════════════════════════
   TOOLBAR WIRING
═══════════════════════════════════════════════════════════ */
document.getElementById('sel-size').onchange = (e) => applyFmt({ fontSize: parseInt(e.target.value) });
document.getElementById('inp-color').oninput  = (e) => applyFmt({ color: e.target.value });
document.getElementById('inp-bg').oninput     = (e) => applyFmt({ bgColor: e.target.value });

document.getElementById('btn-clear-fmt').onclick = () => {
  const sel = hot.getSelected();
  if (!sel) return;
  pushUndo(_snapshotCells(_selCells(sel)));
  for (const [r1, c1, r2, c2] of sel) {
    for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++) {
      for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++) {
        if (cellFormats[r]) delete cellFormats[r][c];
        if (cellBorders[r]) delete cellBorders[r][c];
      }
    }
  }
  _isDirty = true;
  hot.render();
  const s = hot.getSelected();
  if (s && s.length) syncToolbar(s[0][0], s[0][1]);
  showToast('Formatting cleared.');
};

/* ═══════════════════════════════════════════════════════════
   CLIPBOARD
   internalClipboard stores the full cell state (values, formatting,
   borders) so that a same-session paste restores everything.
   A plain TSV is also written to the system clipboard for
   interoperability with external apps (Excel, Sheets, etc.).
   External pastes (Ctrl+V when the system clipboard differs
   from our last copy) are treated as TSV-only: only values are
   pasted and existing destination formatting/borders are kept.
═══════════════════════════════════════════════════════════ */
let internalClipboard = null; /* { tsv, grid:[[{v, fmt, bfmt}]] } */

async function copyToClipboard() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }

  const tsvRows = [];
  const grid    = [];
  for (let r = rMin; r <= rMax; r++) {
    const rowTsv  = [];
    const rowData = [];
    for (let c = cMin; c <= cMax; c++) {
      const v    = hot.getDataAtCell(r, c);
      const vStr = (v == null) ? '' : String(v);
      rowTsv.push(vStr);
      rowData.push({
        v,
        fmt:  cellFormats[r]?.[c]  ? { ...cellFormats[r][c] }  : null,
        bfmt: cellBorders[r]?.[c]  ? { ...cellBorders[r][c] }  : null,
      });
    }
    tsvRows.push(rowTsv.join('\t'));
    grid.push(rowData);
  }

  const tsv = tsvRows.join('\n');
  internalClipboard = { tsv, grid }; /* set synchronously — used by paste immediately */
  try { await navigator.clipboard.writeText(tsv); }
  catch { /* clipboard API unavailable — internal clipboard still works */ }
}

async function pasteFromClipboard() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;

  const r0 = Math.min(sel[0][0], sel[0][2]);
  const c0 = Math.min(sel[0][1], sel[0][3]);

  /* Check if system clipboard matches our last internal copy */
  let systemText = null;
  try { systemText = await navigator.clipboard.readText(); } catch { /* ignore */ }

  const useInternal = internalClipboard &&
    (!systemText || systemText === internalClipboard.tsv);

  if (useInternal) {
    /* ── Full paste: values + formatting + borders ── */
    const destCells = internalClipboard.grid.flatMap((row, ri) =>
      row.map((_, ci) => [r0 + ri, c0 + ci]));
    pushUndo(_snapshotCells(destCells));
    const changes = [];
    internalClipboard.grid.forEach((row, ri) => {
      row.forEach((cell, ci) => {
        const r = r0 + ri, c = c0 + ci;
        changes.push([r, c, cell.v]);

        /* Restore formatting */
        if (!cellFormats[r]) cellFormats[r] = {};
        if (cell.fmt) cellFormats[r][c] = { ...cell.fmt };
        else          delete cellFormats[r][c];

        /* Restore borders */
        if (!cellBorders[r]) cellBorders[r] = {};
        if (cell.bfmt) cellBorders[r][c] = { ...cell.bfmt };
        else           delete cellBorders[r][c];
        applyBorderToCell(r, c);
      });
    });
    hot.setDataAtCell(changes);
    hot.render();
  } else if (systemText) {
    /* ── External paste: TSV only — formatting/borders untouched ── */
    const parsed = systemText.replace(/\r\n?/g, '\n').trimEnd()
      .split('\n').map(row => row.split('\t'));
    pushUndo(_snapshotCells(parsed.flatMap((row, ri) => row.map((_, ci) => [r0 + ri, c0 + ci]))));
    hot.setDataAtCell(
      parsed.flatMap((row, ri) => row.map((v, ci) => [r0 + ri, c0 + ci, v]))
    );
  } else {
    showToast("Concedi l'accesso agli appunti al browser");
  }
}

/* ── Keyboard shortcuts ─────────────────────────────────────── */
document.addEventListener('keydown', async (e) => {
  if (!(e.ctrlKey || e.metaKey) || e.shiftKey || e.altKey) return;

  if (e.key === 'z') { e.preventDefault(); performUndo();               return; }
  if (e.key === 'b') { e.preventDefault(); toggleFmt('bold');           return; }
  if (e.key === 'i') { e.preventDefault(); toggleFmt('italic');         return; }
  if (e.key === 'u') { e.preventDefault(); toggleFmt('underline');      return; }
  if (e.key === 'c') { e.preventDefault(); await copyToClipboard();     return; }
  if (e.key === 'v') { e.preventDefault(); await pasteFromClipboard();  return; }
  if (e.key === 'x') {
    e.preventDefault();
    await copyToClipboard();
    const s = hot.getSelected();
    if (!s) return;
    const cells = _selCells(s);
    pushUndo(_snapshotCells(cells));
    const changes = cells.map(([r, c]) => {
      if (cellFormats[r]) delete cellFormats[r][c];
      if (cellBorders[r]) delete cellBorders[r][c];
      return [r, c, null];
    });
    hot.setDataAtCell(changes);
    hot.render();
    return;
  }
});

/* ═══════════════════════════════════════════════════════════
   SVG / PNG EXPORT
═══════════════════════════════════════════════════════════ */

/* Get actual rendered column width */
function getColW(col) {
  try { const w = hot.getColWidth(col); return (w > 0) ? w : 50; }
  catch { return 50; }
}

/* Get actual rendered row height (from DOM if available, else fallback) */
function getRowH(row) {
  const td = hot.getCell(row, 0);
  if (td?.parentElement) return td.parentElement.offsetHeight || 50;
  return 50;
}

/* Build SVG markup for the given cell range. Returns { svg, totalW, totalH }.
   Each cell is rendered as a square (cellSize × cellSize) so the grid is
   always uniform. Text is NOT clipped — it can overflow into empty neighbours
   just like a real spreadsheet. Background is always solid white.           */
function buildSvg(rMin, rMax, cMin, cMax) {
  const CS      = cellSize;           /* square cell side */
  const PAD     = Math.round(CS * 0.12); /* horizontal text padding ≈ 12 % */
  const CBORD_W = 1;
  const CBORD_C = '#000000';

  const cols   = cMax - cMin + 1;
  const rows   = rMax - rMin + 1;
  const totalW = cols * CS;
  const totalH = rows * CS;

  /* White background + body content */
  let body = `<rect width="${totalW}" height="${totalH}" fill="#ffffff"/>`;
  let yOff = 0;

  for (let r = rMin; r <= rMax; r++) {
    let xOff = 0;
    for (let c = cMin; c <= cMax; c++) {
      const fmt = cellFormats[r]?.[c] || {};
      const fg  = fmt.color      || '#222222';
      const fs  = fmt.fontSize   || baseFontSize;
      const ff  = fmt.fontFamily || 'Arial';
      const fw  = fmt.bold       ? 'bold'   : 'normal';
      const fi  = fmt.italic     ? 'italic' : 'normal';
      const decParts = [];
      if (fmt.underline) decParts.push('underline');
      if (fmt.strike)    decParts.push('line-through');
      const deco = decParts.join(' ') || 'none';
      const align = fmt.align || 'center';

      /* Cell background */
      if (fmt.bgColor && fmt.bgColor !== '#ffffff') {
        body += `<rect x="${xOff}" y="${yOff}" width="${CS}" height="${CS}" fill="${fmt.bgColor}"/>`;
      }

      /* Text — no clip-path so content is never truncated */
      const val = hot.getDataAtCell(r, c);
      if (val !== null && val !== undefined && val !== '') {
        const tx = align === 'left'  ? xOff + PAD
                 : align === 'right' ? xOff + CS - PAD
                 : xOff + CS / 2;
        const anchor = align === 'left' ? 'start' : align === 'right' ? 'end' : 'middle';
        body +=
          `<text x="${tx}" y="${yOff + CS / 2}" ` +
          `font-family="${escapeXml(ff)}, sans-serif" ` +
          `font-size="${fs}" font-weight="${fw}" font-style="${fi}" ` +
          `text-decoration="${deco}" fill="${fg}" ` +
          `text-anchor="${anchor}" dominant-baseline="middle"` +
          `>${escapeXml(String(val))}</text>`;
      }

      /* Custom borders */
      const b  = cellBorders[r]?.[c] || {};
      const bl = `stroke="${CBORD_C}" stroke-width="${CBORD_W}" stroke-linecap="square"`;
      if (b.top)    body += `<line x1="${xOff}"      y1="${yOff}"      x2="${xOff+CS}" y2="${yOff}"      ${bl}/>`;
      if (b.bottom) body += `<line x1="${xOff}"      y1="${yOff+CS}"   x2="${xOff+CS}" y2="${yOff+CS}"   ${bl}/>`;
      if (b.left)   body += `<line x1="${xOff}"      y1="${yOff}"      x2="${xOff}"    y2="${yOff+CS}"   ${bl}/>`;
      if (b.right)  body += `<line x1="${xOff+CS}"   y1="${yOff}"      x2="${xOff+CS}" y2="${yOff+CS}"   ${bl}/>`;

      xOff += CS;
    }
    yOff += CS;
  }

  const svg =
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<svg xmlns="http://www.w3.org/2000/svg" ` +
    `width="${totalW}" height="${totalH}" ` +
    `viewBox="0 0 ${totalW} ${totalH}">\n` +
    `  ${body}\n</svg>`;

  return { svg, totalW, totalH };
}

/* ── Selection bounding box helper ── */
function selectionBounds() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return null;
  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }
  return { rMin, rMax, cMin, cMax };
}

document.getElementById('btn-svg').onclick = () => {
  const bounds = selectionBounds();
  if (!bounds) { showToast('Select cells first!'); return; }
  const { rMin, rMax, cMin, cMax } = bounds;
  const { svg, totalW, totalH } = buildSvg(rMin, rMax, cMin, cMax);
  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = Object.assign(document.createElement('a'), { href: url, download: `sheet-${Date.now()}.svg` });
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  showToast(`SVG exported — ${totalW}×${totalH}px`);
};

document.getElementById('btn-png').onclick = () => {
  const bounds = selectionBounds();
  if (!bounds) { showToast('Select cells first!'); return; }
  const { rMin, rMax, cMin, cMax } = bounds;
  const { svg, totalW, totalH } = buildSvg(rMin, rMax, cMin, cMax);

  const scale  = 2; /* 2× for crisp retina output */
  const canvas = Object.assign(document.createElement('canvas'), {
    width:  totalW * scale,
    height: totalH * scale,
  });
  const ctx = canvas.getContext('2d');
  ctx.scale(scale, scale);

  const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const img  = new Image();
  img.onload = () => {
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);
    const pngUrl = canvas.toDataURL('image/png');
    const a = Object.assign(document.createElement('a'), { href: pngUrl, download: `sheet-${Date.now()}.png` });
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    showToast(`PNG exported — ${totalW}×${totalH}px (${scale}×)`);
  };
  img.onerror = () => { URL.revokeObjectURL(url); showToast('PNG export failed.'); };
  img.src = url;
};

/* ═══════════════════════════════════════════════════════════
   CUSTOM BORDERS
   State is tracked in cellBorders[row][col] = { top, right, bottom, left }
   (cellBorders is declared above, before Handsontable initialization)
═══════════════════════════════════════════════════════════ */

function getBordFmt(row, col) {
  if (!cellBorders[row]) cellBorders[row] = {};
  if (!cellBorders[row][col]) cellBorders[row][col] = {};
  return cellBorders[row][col];
}

/* applyBorderToCell: kept for paste compatibility — borders live in
   cellBorders store and are rendered by afterRenderer (virtual). */
function applyBorderToCell(/* row, col — no-op, hot.render() called by caller */) {}

function toggleBorder(side) {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  pushUndo(_snapshotCells(_selCells(sel)));

  const enable = !getBordFmt(sel[0][0], sel[0][1])[side];

  for (const [r1, c1, r2, c2] of sel) {
    const rMin = Math.min(r1, r2), rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2), cMax = Math.max(c1, c2);
    for (let r = rMin; r <= rMax; r++)
      for (let c = cMin; c <= cMax; c++)
        getBordFmt(r, c)[side] = enable;
  }
  _isDirty = true;
  hot.render();
  syncToolbar(sel[0][0], sel[0][1]);
}

document.getElementById('btn-bord-t').onclick = () => toggleBorder('top');
document.getElementById('btn-bord-l').onclick = () => toggleBorder('left');
document.getElementById('btn-bord-b').onclick = () => toggleBorder('bottom');
document.getElementById('btn-bord-r').onclick = () => toggleBorder('right');

/* Outer border: draws a border only on the perimeter of the selection box,
   leaving inner cells untouched. */
document.getElementById('btn-bord-a').onclick = () => {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  pushUndo(_snapshotCells(_selCells(sel)));

  /* Compute the overall bounding box across all selection areas */
  let rMin = Infinity, rMax = -Infinity, cMin = Infinity, cMax = -Infinity;
  for (const [r1, c1, r2, c2] of sel) {
    rMin = Math.min(rMin, r1, r2); rMax = Math.max(rMax, r1, r2);
    cMin = Math.min(cMin, c1, c2); cMax = Math.max(cMax, c1, c2);
  }

  for (let r = rMin; r <= rMax; r++) {
    for (let c = cMin; c <= cMax; c++) {
      const onEdge = r === rMin || r === rMax || c === cMin || c === cMax;
      if (!onEdge) continue;
      const b = getBordFmt(r, c);
      if (r === rMin) b.top    = true;
      if (r === rMax) b.bottom = true;
      if (c === cMin) b.left   = true;
      if (c === cMax) b.right  = true;
    }
  }
  _isDirty = true;
  hot.render();
  syncToolbar(sel[0][0], sel[0][1]);
};

/* ═══════════════════════════════════════════════════════════
   BORDER POPUP  (Ctrl/Cmd + click on any cell)
═══════════════════════════════════════════════════════════ */
const _borderPopup = document.getElementById('border-popup');

function _syncBorderPopup() {
  const sel = hot.getSelected();
  if (!sel || !sel.length) return;
  const [r, c] = sel[0];
  const bfmt = cellBorders[r]?.[c] || {};
  _borderPopup.querySelectorAll('[data-side]').forEach(btn => {
    btn.classList.toggle('active', !!bfmt[btn.dataset.side]);
  });
}

function _showBorderPopup(x, y) {
  _syncBorderPopup();
  _borderPopup.style.display = 'flex';
  const pw = _borderPopup.offsetWidth || 168;
  const left = Math.min(x + 4, window.innerWidth - pw - 8);
  const top  = Math.min(y + 4, window.innerHeight - 50);
  _borderPopup.style.left = left + 'px';
  _borderPopup.style.top  = top  + 'px';
}

/* Track mouse position over the sheet for Ctrl/Cmd popup */
let _sheetMouseTarget = null;
let _sheetMousePos    = { x: 0, y: 0 };
const _sheetEl = document.getElementById('sheet');
_sheetEl.addEventListener('mousemove', e => {
  _sheetMouseTarget = e.target;
  _sheetMousePos    = { x: e.clientX, y: e.clientY };
});
_sheetEl.addEventListener('mouseleave', () => { _sheetMouseTarget = null; });

/* Show popup when Ctrl/Cmd is pressed while hovering a data cell */
document.addEventListener('keydown', e => {
  if ((e.key === 'Control' || e.key === 'Meta') && _sheetMouseTarget?.closest('td')) {
    _showBorderPopup(_sheetMousePos.x, _sheetMousePos.y);
  }
});

/* Hide popup when Ctrl/Cmd is released */
document.addEventListener('keyup', e => {
  if (e.key === 'Control' || e.key === 'Meta') {
    _borderPopup.style.display = 'none';
  }
});

/* Also hide popup when clicking anywhere outside it */
document.addEventListener('mousedown', e => {
  if (!_borderPopup.contains(e.target)) _borderPopup.style.display = 'none';
});

/* ═══════════════════════════════════════════════════════════
   GRID TOGGLE + SIZE
   (gridVisible is declared above, before Handsontable initialization)
═══════════════════════════════════════════════════════════ */
document.getElementById('btn-grid').onclick = () => {
  gridVisible = !gridVisible;
  document.getElementById('btn-grid').classList.toggle('active', gridVisible);
  hot.render();
};

document.getElementById('btn-grid-minus').onclick = () => {
  cellSize     = Math.max(16, cellSize - 6);
  baseFontSize = Math.round(cellSize * 16 / 36);
  hot.updateSettings({ colWidths: cellSize, rowHeights: cellSize });
};
document.getElementById('btn-grid-plus').onclick = () => {
  cellSize     = Math.min(150, cellSize + 6);
  baseFontSize = Math.round(cellSize * 16 / 36);
  hot.updateSettings({ colWidths: cellSize, rowHeights: cellSize });
};

/* Resize */
window.addEventListener('resize', () => hot.refreshDimensions());

/* ═══════════════════════════════════════════════════════════
   IMPORT / EXPORT
   • xlsx/ods/csv — via SheetJS (data only)
   • .wsheet      — JSON snapshot with data + formatting + borders
═══════════════════════════════════════════════════════════ */

/* ── Export: .wsheet (full state — data + formatting + borders) ── */
function exportWSheet() {
  /* Trim trailing empty rows from data */
  const raw = hot.getData();
  let lastRow = raw.length - 1;
  while (lastRow >= 0 && raw[lastRow].every(v => v === null || v === '')) lastRow--;

  const state = {
    version: 1,
    data:    raw.slice(0, lastRow + 1),
    formats: cellFormats,
    borders: cellBorders,
  };
  const json = JSON.stringify(state);
  const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = Object.assign(document.createElement('a'), {
    href: url, download: `websheet-${Date.now()}.wsheet`,
  });
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  showToast('Saved: websheet.wsheet');
}

/* ── .wsheet loader (shared by file import and auto-load) ── */
async function loadWSheetText(text, name) {
  const state = JSON.parse(text);
  if (!state || state.version !== 1) throw new Error('Invalid format');

  document.getElementById('st-msg').textContent = 'Loading…';
  await new Promise(r => requestAnimationFrame(r)); /* yield — browser paints "Loading…" */

  /* Clear current state */
  Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
  Object.keys(cellBorders).forEach(k => delete cellBorders[k]);

  /* Load data */
  hot.loadData(state.data || []);

  /* Restore formatting */
  if (state.formats) {
    for (const [r, cols] of Object.entries(state.formats))
      for (const [c, fmt] of Object.entries(cols)) {
        if (!cellFormats[r]) cellFormats[r] = {};
        cellFormats[r][c] = fmt;
      }
  }

  /* Restore borders into store — afterRenderer applies them (virtual, no plugin) */
  if (state.borders) {
    for (const [r, cols] of Object.entries(state.borders))
      for (const [c, bfmt] of Object.entries(cols)) {
        if (!cellBorders[r]) cellBorders[r] = {};
        cellBorders[r][c] = bfmt;
      }
  }

  hot.render(); /* single render — afterRenderer applies formats + borders for visible cells */
  _isDirty = false;
  document.getElementById('st-msg').textContent = '';
  if (name) showToast(`Opened: ${name}`);
}

/* ═══════════════════════════════════════════════════════════
   GOOGLE SHEETS HTML IMPORT
   Parses the CSS classes from the <style> block, then reads
   the .waffle table cells applying borders + formatting.
═══════════════════════════════════════════════════════════ */
function parsePtPx(val) {
  const pt = val.match(/^([\d.]+)pt$/i);
  if (pt) return Math.round(parseFloat(pt[1]) * 1.333);
  const px = val.match(/^([\d.]+)px$/i);
  if (px) return Math.round(parseFloat(px[1]));
  return null;
}

function normColor(val) {
  val = val.trim();
  if (val.startsWith('#')) return val.toLowerCase();
  const m = val.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
  if (m) return '#' + [m[1], m[2], m[3]].map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
  return null;
}

function parseCssClass(decls) {
  const result = {};
  for (const raw of decls.split(';')) {
    const colon = raw.indexOf(':');
    if (colon === -1) continue;
    const key = raw.slice(0, colon).trim().toLowerCase();
    const val = raw.slice(colon + 1).trim();
    const vl  = val.toLowerCase();

    if (key === 'font-weight' && vl === 'bold')   { result.bold = true; continue; }
    if (key === 'font-style'  && vl === 'italic')  { result.italic = true; continue; }
    if (key === 'color')       { const c = normColor(val); if (c) result.color = c; continue; }
    if (key === 'background-color') { const c = normColor(val); if (c) result.bgColor = c; continue; }
    if (key === 'text-align')  { if (['left','center','right'].includes(vl)) result.align = vl; continue; }
    if (key === 'font-size')   { const s = parsePtPx(val); if (s) result.fontSize = s; continue; }
    if (key === 'font-family') {
      const families = val.split(',').map(f => f.replace(/["']/g, '').trim());
      result.fontFamily = families.find(f => !f.toLowerCase().startsWith('docs-')) || families[0];
      continue;
    }
    /* Borders: value like "1px SOLID #000000" means on; "none" means off */
    if (key === 'border-top')    { result.borderTop    = !vl.includes('none'); continue; }
    if (key === 'border-bottom') { result.borderBottom = !vl.includes('none'); continue; }
    if (key === 'border-left')   { result.borderLeft   = !vl.includes('none'); continue; }
    if (key === 'border-right')  { result.borderRight  = !vl.includes('none'); continue; }
  }
  return result;
}

function handleGoogleSheetsHtml(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const doc = new DOMParser().parseFromString(e.target.result, 'text/html');

      /* 1 ── Parse CSS class map */
      const styleMap = {};
      for (const styleEl of doc.querySelectorAll('style')) {
        const re = /\.waffle\s+\.(\w+)\s*\{([^}]*)\}/g;
        let m;
        while ((m = re.exec(styleEl.textContent)) !== null) {
          styleMap[m[1]] = parseCssClass(m[2]);
        }
      }

      /* 2 ── Read waffle table */
      const table = doc.querySelector('table.waffle');
      if (!table) throw new Error('No Google Sheets table found (table.waffle missing)');

      const aoa        = [];
      const newFormats = {};
      const newBorders = {};

      for (const tr of table.querySelectorAll('tbody tr')) {
        const cells   = tr.querySelectorAll('td');
        const rowIdx  = aoa.length;
        const rowData = [];

        cells.forEach((td, colIdx) => {
          rowData.push(td.textContent.trim());

          const cls = (td.className || '').trim();
          const s   = styleMap[cls];
          if (!s) return;

          /* Formatting */
          const fmt = {};
          if (s.bold)       fmt.bold       = true;
          if (s.italic)     fmt.italic     = true;
          if (s.color     && s.color     !== '#000000') fmt.color     = s.color;
          if (s.bgColor   && s.bgColor   !== '#ffffff') fmt.bgColor   = s.bgColor;
          if (s.fontSize)   fmt.fontSize   = s.fontSize;
          if (s.fontFamily) fmt.fontFamily = s.fontFamily;
          if (s.align)      fmt.align      = s.align;
          if (Object.keys(fmt).length) {
            if (!newFormats[rowIdx]) newFormats[rowIdx] = {};
            newFormats[rowIdx][colIdx] = fmt;
          }

          /* Borders */
          if (s.borderTop || s.borderBottom || s.borderLeft || s.borderRight) {
            if (!newBorders[rowIdx]) newBorders[rowIdx] = {};
            newBorders[rowIdx][colIdx] = {
              top:    !!s.borderTop,
              bottom: !!s.borderBottom,
              left:   !!s.borderLeft,
              right:  !!s.borderRight,
            };
          }
        });

        aoa.push(rowData);
      }

      /* 3 ── Load into Handsontable */
      Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
      Object.keys(cellBorders).forEach(k => delete cellBorders[k]);
      hot.loadData(aoa);

      for (const [r, cols] of Object.entries(newFormats)) {
        if (!cellFormats[r]) cellFormats[r] = {};
        Object.assign(cellFormats[r], cols);
      }
      for (const [r, cols] of Object.entries(newBorders)) {
        if (!cellBorders[r]) cellBorders[r] = {};
        for (const [c, bfmt] of Object.entries(cols)) cellBorders[r][c] = bfmt;
      }

      hot.render(); /* single render */
      const borderTotal = Object.values(newBorders).reduce((n, cols) => n + Object.keys(cols).length, 0);
      showToast(`Opened: ${file.name} (${aoa.length} rows, ${borderTotal} bordered cells)`);
    } catch (err) {
      showToast(`Error: ${err.message}`);
    }
  };
  reader.readAsText(file, 'utf-8');
}

/* ── Import: detect format and load ── */
function handleFileImport(file) {
  if (!file) return;
  const name = file.name.toLowerCase();

  if (name.endsWith('.html') || name.endsWith('.htm')) {
    handleGoogleSheetsHtml(file);
    return;
  }

  if (name.endsWith('.wsheet')) {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try { await loadWSheetText(e.target.result, file.name); }
      catch (err) { showToast(`Error: ${err.message}`); }
    };
    reader.readAsText(file);

  } else {
    /* ── xlsx / ods / csv / xls: SheetJS ── */
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb   = XLSX.read(data, { type: 'array', cellStyles: true });
        const ws   = wb.Sheets[wb.SheetNames[0]];
        const aoa  = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });

        /* Clear formatting and borders */
        Object.keys(cellFormats).forEach(k => delete cellFormats[k]);
        Object.keys(cellBorders).forEach(k => delete cellBorders[k]);

        hot.loadData(aoa);

        /* Extract borders from xlsx cell styles into store */
        const ref = ws['!ref'];
        if (ref) {
          const range = XLSX.utils.decode_range(ref);
          for (let r = range.s.r; r <= range.e.r; r++) {
            for (let c = range.s.c; c <= range.e.c; c++) {
              const cell = ws[XLSX.utils.encode_cell({ r, c })];
              if (!cell?.s?.border) continue;
              const b = cell.s.border;
              if (!b.top?.style && !b.bottom?.style && !b.left?.style && !b.right?.style) continue;
              if (!cellBorders[r]) cellBorders[r] = {};
              cellBorders[r][c] = {
                top:    !!b.top?.style,
                bottom: !!b.bottom?.style,
                left:   !!b.left?.style,
                right:  !!b.right?.style,
              };
            }
          }
        }

        hot.render(); /* single render */
        showToast(`Opened: ${file.name} (${wb.SheetNames[0]})`);
      } catch (err) {
        showToast(`Error reading file: ${err.message}`);
      }
    };
    reader.readAsArrayBuffer(file);
  }
}

/* ── Wire buttons ── */
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', (e) => {
  handleFileImport(e.target.files[0]);
  e.target.value = ''; /* reset so the same file can be opened again */
});

document.getElementById('btn-open').onclick    = () => fileInput.click();
document.getElementById('btn-save-ws').onclick = exportWSheet;

/* ═══════════════════════════════════════════════════════════
   FILE LIBRARY PANEL
═══════════════════════════════════════════════════════════ */
let libraryOpen   = false;
let activeEntry   = null;

const filePanel   = document.getElementById('file-panel');
const fileListEl  = document.getElementById('file-list');
const btnLibrary  = document.getElementById('btn-library');

function toggleLibrary() {
  libraryOpen = !libraryOpen;
  filePanel.classList.toggle('closed', !libraryOpen);
  btnLibrary.classList.toggle('active', libraryOpen);
  if (libraryOpen) {
    hot.refreshDimensions();
    /* Load from Firebase if the user is logged in, otherwise prompt */
    if (typeof currentUser !== 'undefined' && currentUser) {
      loadFirebaseLibrary();
    } else {
      fileListEl.innerHTML = '<div style="padding:10px;color:#aaa;font-size:11px;">Login to access the library</div>';
    }
  }
}

btnLibrary.onclick = toggleLibrary;

/* ── Auto-load template on startup ── */
fetch('./data/template.wsheet')
  .then(r => { if (!r.ok) throw new Error(); return r.text(); })
  .then(text => loadWSheetText(text, null).catch(() => {}))
  .catch(() => {}); /* silently skip if file is missing */

/* firebaseConfig è caricato da firebase-config.js (esterno, gitignored) */

/* Folder inside Firebase Storage that contains the .wsheet files */
const STORAGE_FOLDER = 'tables';

/* Declared with let (not const) to avoid Temporal Dead Zone if init fails */
let auth       = null;
let storage    = null;
let realtimeDb = null;
let currentUser      = null;
let currentCloudFile = null;
let _isDirty         = false;

try {
  if (typeof firebase === 'undefined') throw new Error('Firebase SDK not loaded. Check your internet connection.');
  const app = firebase.apps.length ? firebase.apps[0] : firebase.initializeApp(firebaseConfig);
  auth    = firebase.auth(app);
  storage = firebase.storage(app);
  try { realtimeDb = firebase.database(app); } catch(e) { console.warn('RTDB not available:', e.message); }
} catch (e) {
  console.error('Firebase init error:', e);
  showToast('Firebase error: ' + e.message);
}

/* ─── Realtime DB — presence & version helpers ─────────── */

/* Convert filename to a valid RTDB key (no . # $ / [ ]) */
function safeKey(filename) { return filename.replace(/[.#$\/\[\]]/g, '_'); }

let _presenceRef    = null;  /* ref: p/{key}/{uid}  — current user's presence node */
let _editingRef     = null;  /* ref: p/{key}        — all editors on current file  */
let _openedVersion  = null;  /* version timestamp when current file was opened     */

function _clearPresence() {
  if (_presenceRef) { _presenceRef.onDisconnect().cancel(); _presenceRef.remove(); _presenceRef = null; }
  if (_editingRef)  { _editingRef.off(); _editingRef = null; }
  _openedVersion = null;
  const w = document.getElementById('editing-warning');
  w.style.display = 'none'; w.textContent = '';
}

async function _setPresence(filename) {
  if (!realtimeDb || !currentUser) return;
  const key = safeKey(filename);
  _presenceRef = realtimeDb.ref(`p/${key}/${currentUser.uid}`);
  _editingRef  = realtimeDb.ref(`p/${key}`);
  _presenceRef.onDisconnect().remove();          /* auto-cleanup on disconnect */
  await _presenceRef.set(currentUser.email);
  _editingRef.on('value', snap => {
    const editors = snap.val() || {};
    const others = Object.values(
      Object.fromEntries(Object.entries(editors).filter(([uid]) => uid !== currentUser.uid))
    );
    const w = document.getElementById('editing-warning');
    if (others.length) { w.textContent = `✎ Also editing: ${others.join(', ')}`; w.style.display = ''; }
    else               { w.textContent = ''; w.style.display = 'none'; }
  });
}

async function _getVersion(filename) {
  if (!realtimeDb) return null;
  const snap = await realtimeDb.ref(`v/${safeKey(filename)}`).once('value');
  return snap.val();
}

async function _setVersion(filename) {
  if (!realtimeDb) return;
  const v = Date.now();
  await realtimeDb.ref(`v/${safeKey(filename)}`).set(v);
  _openedVersion = v;
}

async function _versionConflict(filename) {
  if (!realtimeDb || _openedVersion === null) return false;
  const current = await _getVersion(filename);
  return current !== null && current !== _openedVersion;
}

/* ─── Auth state observer ─────────────────────────────── */
if (auth) auth.onAuthStateChanged(user => {
  currentUser = user;
  if (user) {
    document.getElementById('user-email').textContent    = user.email;
    document.getElementById('user-info').style.display   = 'flex';
    document.getElementById('btn-login').style.display   = 'none';
    document.getElementById('btn-save-cloud').style.display = 'inline-flex';
    document.getElementById('btn-new-file').style.display   = 'block';
    /* If the library panel is already open, refresh it from Firebase */
    if (libraryOpen) loadFirebaseLibrary();
  } else {
    document.getElementById('user-info').style.display   = 'none';
    document.getElementById('btn-login').style.display   = '';
    document.getElementById('btn-save-cloud').style.display = 'none';
    document.getElementById('btn-new-file').style.display   = 'none';
    currentCloudFile = null;
  }
});

/* ─── Login modal ─────────────────────────────────────── */
function showLoginModal() {
  document.getElementById('login-email').value       = '';
  document.getElementById('login-password').value    = '';
  document.getElementById('login-error').textContent  = '';
  document.getElementById('btn-login-submit').disabled = false;
  document.getElementById('login-overlay').classList.add('show');
  setTimeout(() => document.getElementById('login-email').focus(), 150);
}

function hideLoginModal() {
  document.getElementById('login-overlay').classList.remove('show');
}

async function submitLogin() {
  const email    = document.getElementById('login-email').value.trim();
  const password = document.getElementById('login-password').value;
  const errEl    = document.getElementById('login-error');
  const btn      = document.getElementById('btn-login-submit');
  if (!auth) { errEl.textContent = 'Firebase not available. Check your connection and reload the page.'; return; }
  if (!email || !password) { errEl.textContent = 'Insert email and password.'; return; }

  btn.disabled = true;
  errEl.textContent = '';
  try {
    await auth.signInWithEmailAndPassword(email, password);
    hideLoginModal();
    showToast('Login successful!');
  } catch (err) {
    btn.disabled = false;
    const msgs = {
      'auth/user-not-found':    'User not found.',
      'auth/wrong-password':    'Wrong password.',
      'auth/invalid-email':     'Invalid email.',
      'auth/too-many-requests': 'Too many attempts. Try again later.',
      'auth/invalid-credential':'Invalid credentials.',
    };
    errEl.textContent = msgs[err.code] || `Error: ${err.message}`;
  }
}

function logoutUser() {
  if (!auth) return;
  _clearPresence();
  auth.signOut().then(() => {
    showToast('Logged out.');
    if (libraryOpen) {
      fileListEl.innerHTML = '<div style="padding:10px;color:#aaa;font-size:11px;">Login to access the library</div>';
    }
  });
}

/* Enter key in login fields */
document.getElementById('login-email').addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('login-password').focus();
});
document.getElementById('login-password').addEventListener('keydown', e => {
  if (e.key === 'Enter') submitLogin();
});
/* Close modal by clicking outside */
document.getElementById('login-overlay').addEventListener('click', e => {
  if (e.target === document.getElementById('login-overlay')) hideLoginModal();
});

/* ─── Firebase Storage — Library ──────────────────────── */
async function loadFirebaseLibrary() {
  if (!storage) { fileListEl.innerHTML = '<div style="padding:10px;color:#d32f2f;font-size:11px;">Firebase not available</div>'; return; }
  fileListEl.innerHTML = '<div style="padding:10px;color:#aaa;font-size:11px;">Loading…</div>';
  try {
    const ref    = storage.ref(STORAGE_FOLDER);
    const result = await ref.listAll();
    const files  = result.items
      .filter(item => item.name.toLowerCase().endsWith('.wsheet'))
      .map(item => item.name)
      .sort((a, b) => a.localeCompare(b));

    if (files.length === 0) {
      fileListEl.innerHTML = '<div style="padding:10px;color:#aaa;font-size:11px;">No files found</div>';
      return;
    }
    fileListEl.innerHTML = '';
    for (const f of files) {
      fileListEl.appendChild(makeFileEntry(f));
    }
  } catch (err) {
    fileListEl.innerHTML = `<div style="padding:10px;color:#d32f2f;font-size:11px;">Error: ${err.message}</div>`;
  }
}

async function autoSaveCurrentFile() {
  if (!storage || !currentUser || !currentCloudFile) return;
  if (!_isDirty) return;
  /* Skip auto-save if someone else modified the file in the meantime */
  if (await _versionConflict(currentCloudFile)) {
    showToast(`⚠ Auto-save skipped: "${currentCloudFile}" was modified by another user.`);
    return;
  }
  const raw = hot.getData();
  let lastRow = raw.length - 1;
  while (lastRow >= 0 && raw[lastRow].every(v => v === null || v === '')) lastRow--;
  const blob = new Blob([JSON.stringify({ version:1, data: raw.slice(0, lastRow+1), formats: cellFormats, borders: cellBorders })],
                        { type: 'application/json;charset=utf-8' });
  try {
    await storage.ref(`${STORAGE_FOLDER}/${currentCloudFile}`).put(blob, { contentType: 'application/json' });
    await _setVersion(currentCloudFile);
    _isDirty = false;
    showToast(`Auto-saved: ${currentCloudFile}`);
  } catch (err) {
    showToast(`Auto-save failed: ${err.message}`);
  }
}

async function loadFirebaseFile(filename, entryEl) {
  /* Auto-save the currently open cloud file before switching */
  if (currentCloudFile && currentCloudFile !== filename) {
    await autoSaveCurrentFile();
  }
  /* Clear presence for the previous file */
  _clearPresence();
  try {
    const url  = await storage.ref(`${STORAGE_FOLDER}/${filename}`).getDownloadURL();
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    await loadWSheetText(text, filename);
    if (activeEntry) activeEntry.classList.remove('active');
    activeEntry = entryEl;
    entryEl.classList.add('active');
    currentCloudFile = filename;
    /* Read version + register presence (fires real-time warning if others are editing) */
    _openedVersion = await _getVersion(filename);
    await _setPresence(filename);
  } catch (err) {
    showToast(`Error loading ${filename}: ${err.message}`);
  }
}

/* ─── Save in Cloud ───────────────────────────────────── */
async function saveToCloud() {
  if (!auth || !storage) { showToast('Firebase not available.'); return; }
  if (!currentUser) { showToast('You must be logged in to save.'); return; }

  /* Build the .wsheet JSON (same as exportWSheet) */
  const raw = hot.getData();
  let lastRow = raw.length - 1;
  while (lastRow >= 0 && raw[lastRow].every(v => v === null || v === '')) lastRow--;
  const state = {
    version: 1,
    data:    raw.slice(0, lastRow + 1),
    formats: cellFormats,
    borders: cellBorders,
  };
  const json = JSON.stringify(state);
  const blob = new Blob([json], { type: 'application/json;charset=utf-8' });

  /* Use the current Firebase filename, or ask for a new one */
  let filename = currentCloudFile;
  if (!filename) {
    const name = prompt('File name to save (without extension):');
    if (!name) return;
    filename = name.trim().replace(/\.wsheet$/i, '') + '.wsheet';
  }

  const btn = document.getElementById('btn-save-cloud');
  btn.disabled = true;
  btn.textContent = '⏳ Saving…';

  try {
    /* Version conflict check — warn before overwriting */
    if (await _versionConflict(filename)) {
      const overwrite = confirm(`⚠ "${filename}" was modified by another user since you opened it.\n\nOverwrite their changes?`);
      if (!overwrite) { btn.disabled = false; btn.innerHTML = '&#9729; Save in cloud'; return; }
    }
    await storage.ref(`${STORAGE_FOLDER}/${filename}`).put(blob, { contentType: 'application/json' });
    await _setVersion(filename);
    currentCloudFile = filename;
    _isDirty = false;
    showToast(`✓ Saved to cloud: ${filename}`);
    /* Refresh library list if open */
    if (libraryOpen) loadFirebaseLibrary();
  } catch (err) {
    showToast(`✗ Upload failed: ${err.message}`);
  } finally {
    btn.disabled = false;
    btn.innerHTML = '&#9729; Save in cloud';
  }
}

/* ═══════════════════════════════════════════════════════════
   LIBRARY — CREATE / RENAME / DELETE
═══════════════════════════════════════════════════════════ */

/* Build a file-entry element with name + action buttons */
function makeFileEntry(filename) {
  const el = document.createElement('div');
  el.className = 'file-entry';
  el.dataset.filename = filename;

  const nameEl = document.createElement('span');
  nameEl.className = 'file-entry-name';
  nameEl.textContent = filename.replace(/\.wsheet$/i, '');
  nameEl.title = filename;
  nameEl.onclick = () => loadFirebaseFile(filename, el);

  const actions = document.createElement('span');
  actions.className = 'file-entry-actions';

  const btnRename = document.createElement('button');
  btnRename.className = 'fe-btn';
  btnRename.title = 'Rename';
  btnRename.textContent = '✎';
  btnRename.onclick = e => { e.stopPropagation(); showRenameModal(filename); };

  const btnDel = document.createElement('button');
  btnDel.className = 'fe-btn del';
  btnDel.title = 'Delete';
  btnDel.textContent = '✕';
  btnDel.onclick = e => { e.stopPropagation(); showDeleteModal(filename); };

  actions.appendChild(btnRename);
  actions.appendChild(btnDel);
  el.appendChild(nameEl);
  el.appendChild(actions);
  return el;
}

/* ── Name input modal (shared by New file and Rename) ── */
let _libNameMode   = 'new';   /* 'new' | 'rename' */
let _libNameTarget = null;    /* original filename when renaming */

function showNewFileModal() {
  _libNameMode   = 'new';
  _libNameTarget = null;
  document.getElementById('libname-title').textContent    = 'New file';
  document.getElementById('libname-input').value          = '';
  document.getElementById('libname-error').textContent    = '';
  document.getElementById('libname-overlay').classList.add('show');
  setTimeout(() => document.getElementById('libname-input').focus(), 150);
}

function showRenameModal(filename) {
  _libNameMode   = 'rename';
  _libNameTarget = filename;
  document.getElementById('libname-title').textContent    = 'Rename file';
  document.getElementById('libname-input').value          = filename.replace(/\.wsheet$/i, '');
  document.getElementById('libname-error').textContent    = '';
  document.getElementById('libname-overlay').classList.add('show');
  setTimeout(() => {
    const inp = document.getElementById('libname-input');
    inp.focus(); inp.select();
  }, 150);
}

function hideLibNameModal() {
  document.getElementById('libname-overlay').classList.remove('show');
}

async function submitLibName() {
  const raw  = document.getElementById('libname-input').value.trim();
  const errEl = document.getElementById('libname-error');
  if (!raw) { errEl.textContent = 'Enter a file name.'; return; }
  const filename = raw.replace(/\.wsheet$/i, '') + '.wsheet';

  if (_libNameMode === 'rename' && filename === _libNameTarget) { hideLibNameModal(); return; }

  const btn = document.getElementById('btn-libname-ok');
  btn.disabled = true;
  errEl.textContent = '';
  try {
    if (_libNameMode === 'new') {
      /* Use template.wsheet as initial content, fallback to empty wsheet */
      let content;
      try {
        const tr = await fetch('./data/template.wsheet');
        content = tr.ok ? await tr.text() : null;
      } catch { content = null; }
      if (!content) content = JSON.stringify({ version:1, data: Array.from({length:50}, () => Array(50).fill('')), formats:{}, borders:{} });
      const blob = new Blob([content], { type: 'application/json;charset=utf-8' });
      await storage.ref(`${STORAGE_FOLDER}/${filename}`).put(blob, { contentType: 'application/json' });
      /* Open the newly created file immediately */
      await loadWSheetText(content, filename);
      currentCloudFile = filename;
      showToast(`Created and opened: ${filename}`);
    } else {
      /* Rename = download old + upload new + delete old */
      const url  = await storage.ref(`${STORAGE_FOLDER}/${_libNameTarget}`).getDownloadURL();
      const resp = await fetch(url);
      const blob = await resp.blob();
      await storage.ref(`${STORAGE_FOLDER}/${filename}`).put(blob, { contentType: 'application/json' });
      await storage.ref(`${STORAGE_FOLDER}/${_libNameTarget}`).delete();
      /* Update state if renamed file was the open one */
      if (currentCloudFile === _libNameTarget) currentCloudFile = filename;
      showToast(`Renamed to: ${filename}`);
    }
    hideLibNameModal();
    await loadFirebaseLibrary();
    /* Highlight the file in the list (new or renamed) */
    for (const el of fileListEl.querySelectorAll('.file-entry')) {
      if (el.dataset.filename === filename) {
        if (activeEntry) activeEntry.classList.remove('active');
        activeEntry = el;
        el.classList.add('active');
        break;
      }
    }
  } catch (err) {
    errEl.textContent = 'Error: ' + err.message;
  } finally {
    btn.disabled = false;
  }
}

document.getElementById('libname-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') submitLibName();
  if (e.key === 'Escape') hideLibNameModal();
});
document.getElementById('libname-overlay').addEventListener('click', e => {
  if (e.target === document.getElementById('libname-overlay')) hideLibNameModal();
});

/* ── Delete confirm modal ── */
let _libDelTarget = null;

function showDeleteModal(filename) {
  _libDelTarget = filename;
  document.getElementById('libdel-msg').textContent =
    `Are you sure you want to delete "${filename.replace(/\.wsheet$/i, '')}"?`;
  document.getElementById('libdel-overlay').classList.add('show');
}

function hideLibDelModal() {
  document.getElementById('libdel-overlay').classList.remove('show');
}

async function submitLibDel() {
  if (!_libDelTarget) return;
  const btn = document.getElementById('btn-libdel-ok');
  btn.disabled = true;
  try {
    await storage.ref(`${STORAGE_FOLDER}/${_libDelTarget}`).delete();
    if (currentCloudFile === _libDelTarget) currentCloudFile = null;
    showToast(`Deleted: ${_libDelTarget}`);
    hideLibDelModal();
    loadFirebaseLibrary();
  } catch (err) {
    showToast('Delete failed: ' + err.message);
  } finally {
    btn.disabled = false;
  }
}

document.getElementById('libdel-overlay').addEventListener('click', e => {
  if (e.target === document.getElementById('libdel-overlay')) hideLibDelModal();
});
</script>
</body>
</html>
